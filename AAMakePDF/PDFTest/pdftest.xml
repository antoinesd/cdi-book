<?xml version="1.0" encoding="UTF-8"?><book xmlns:notdefault="http://www.manning.com/schemas/book" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ns="http://www.manning.com/schemas/book">

<toc>
<tocfront pagenum="i">Preface</tocfront>
<tocpart>
  <tocentry>Part 1:  The Groovy language</tocentry>
  <tocchap>
    <tocentry>1 Your way to Groovy</tocentry>
  </tocchap>
  <tocchap>
    <tocentry>2 Overture: The Groovy basics </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>3 The simple Groovy datatypes </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>4 The collective Groovy datatypes</tocentry>
  </tocchap>
  <tocchap>
    <tocentry>5 Working with closures </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>6 Groovy control structures </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>7 Dynamic object orientation, Groovy style </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>8 Groovy Meta Programming</tocentry>
  </tocchap>
</tocpart>
<tocpart>
  <tocentry>Part II: Around the Groovy library</tocentry>
  <tocchap>
    <tocentry>9 Working with builders </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>10 Working with the GDK </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>11 Database programming with Groovy </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>12 Integrating Groovy </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>13 Working with XML </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>14 Unit testing with Groovy </tocentry>
  </tocchap>
</tocpart>
<tocpart>
  <tocentry>Part III: Everyday Groovy  </tocentry>
  <tocchap>
    <tocentry>15 Tips and tricks </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>16 Groovy modules and frameworks</tocentry>
  </tocchap>
  <tocchap>
    <tocentry>17 Concurrent programming with Groovy </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>18 Creating Domain Specific Languages </tocentry>
  </tocchap>
  <tocchap>
    <tocentry>19 Groovy best practice patterns </tocentry>
  </tocchap>
</tocpart>
<tocback>Appendix A: Installation and documentation </tocback>
<tocback>Appendix B: Groovy language info </tocback>
<tocback>Appendix C: GDK API quick reference </tocback>
<tocback>Appendix D: Cheat sheets</tocback>
</toc>



  <chapter id="config.ch" label="2">
    <title id="_7_0_512">Configuring Mule</title>
    
    <abstract>
    <para>In this chapter</para>
<itemizedlist><listitem>Communicating with the MuleClient</listitem>
<listitem>Using context objects to interact with Mule</listitem>
<listitem>AOP with component interceptors</listitem>
<listitem>Leveraging the notification framework</listitem></itemizedlist>
    </abstract>
    
    
    
    <para id="_7_0_513"><internalnote>YOU MUST NOT SEE THIS!!!</internalnote>In this chapter, you'll learn the fundamental
    principles of a Mule configuration file. Said differently, this chapter
    will give you the grammar of the configuration file, while the upcoming
    chapters will help you build your vocabulary. When you're done reading it,
    you'll be able to create new configuration files and set up the scene for
    your own services, which you'll learn to create in the coming
    chapters.</para><para id="_7_0_514">In essence, configuring Mule consists of defining the
    services you want to be active in a particular instance of the ESB. As
    seen in the previous chapter, these services are composed of and rely on
    many different moving parts, which also need to be configured. Some of
    these moving parts are intrinsically shared across several services, such
    as connectors. Others can be locally defined or globally configured and
    shared, such as endpoints. As you can guess, supporting this flexibility
    and richness in a configuration mechanism is pretty hairy.</para><para id="_7_0_515">To achieve this, Mule uses <emphasis>configuration
    builders</emphasis> <indexterm><primary>configuration</primary><secondary>builder</secondary></indexterm>that can translate a human-authored configuration file into
    the complex graph of objects that constitutes a running node of this ESB.
    The main builders are of two kinds: a Spring-driven builder, which works
    with XML files, and a script builder, which can accept scripting language
    files.</para><note id="_7_0_516"><title>The scripting configuration builder</title>
      <para id="_7_0_517">The scripting configuration builder  <indexterm><primary>configuration</primary><secondary>scripted</secondary></indexterm> <indexterm><primary>scripting</primary></indexterm>uses a script in any language for which a
      JSR-223 compliant <indexterm><primary>JSR-223</primary><see>scripting</see></indexterm> engine exists (such as Groovy, JRuby, or Rhino). By
      default, Mule supports Groovy <indexterm><primary>Groovy</primary></indexterm>configuration files, but other scripting languages can be
      added by installing the Mule Scripting Pack that can be downloaded from
      <code>http://mulesource.org/display/MULE/Download</code>. A scripted       configuration is a low-level approach to configuring Mule. It's up to       you to instantiate, configure, and wire all the necessary moving parts.       This requires an expert knowledge of Mule internals. This explains why       this approach is much less popular than XML configuration, as it's rare
      that anyone needs this level of control. This said, there can be
      circumstances where using Spring or XML isn't an option. In that
      situation, using a scripted configuration can save the day.</para></note>

    <para id="_7_0_518">In this chapter we'll mainly focus on configuring the
    Spring XML <indexterm><primary>configuration</primary><secondary>Spring XML</secondary><tertiary>advantages</tertiary>
      </indexterm>builder, for several reasons:<orderedlist id="_7_0_519">
        <listitem id="_7_0_520">
          <para id="_7_0_521"><emphasis>It's the most
          popular</emphasis> you're more likely to find examples using this
          syntax.</para></listitem><listitem id="_7_0_522">
          <para id="_7_0_523"><emphasis>It's the most user
          friendly</emphasis> Spring takes care of wiring together all the
          moving parts of the ESB, something you must do by hand with a
          scripted builder.</para></listitem><listitem id="_7_0_524">
          <para id="_7_0_525"><emphasis>It's the most
          expressive</emphasis> dedicated XML schemas define the
          domain-specific language of Mule, allowing you to handle
          higher-level concepts than the scripting approach does.</para></listitem></orderedlist></para><para id="_7_0_526">We'll start by running a simple example, which will
    allow you to look at your first service configuration. We'll then review
    the overall structure, element families, and configurable items of the
    Spring XML file in general terms, just enough for you to get the gist of
    it and have the basic knowledge you'll need to grasp what you'll learn in
    the upcoming chapters. We'll also give some advice on how to organize your
    configuration files efficiently.</para><para id="_7_0_530">Are you ready for the ride? We believe the answer is
    yes, so let's start to look into our first Mule configuration file.</para><sect1 id="ch02.firstride.sec">
      <title id="_7_0_532">First ride</title><para id="_7_0_533">Though Mule comes complete with a 'hello' example,
      we chose to get started with the 'echo' example that's also bundled with
      the platform. We believe the echo example is the true 'hello world'
      example for Mule, as it doesn't require any transformer, custom
      component, or specific router. That's why we decided to nickname it
      'Echo World <indexterm><primary>echo world</primary></indexterm>.'</para><para id="_7_0_535">Let's now look into details of the Echo World
      example <indexterm><primary>Mule</primary><secondary>basic example</secondary></indexterm>. As shown in figure <xref id="_7_0_536" linkend="ch02.echo-sample.fig"/>, this application uses the
      <code>stdio</code> transport <indexterm><primary>stdio</primary><secondary>transport</secondary></indexterm>to receive messages from the console input       (<code>stdin</code>) <indexterm><primary>console</primary><secondary>reading from</secondary><tertiary>stdin</tertiary>
        </indexterm>and send these messages unchanged directly to the console
      output (<code>stdout</code>) <indexterm><primary>console</primary><secondary>writing to</secondary><tertiary>stdout</tertiary>         </indexterm>. A specific component, called a
      <emphasis>bridge</emphasis> <indexterm><primary>component</primary><secondary>bridge</secondary></indexterm>, is used to pass the messages from the inbound router to
      the outbound one. A bridge is a neutral component: it doesn't perform
      any action or modify the messages that it processes. The outbound router
      is a pass-through one <indexterm><primary>pass-through-router</primary></indexterm>: it's the simplest router that exists. It dispatches the
      messages it receives to a unique endpoint.<figure id="ch02.echo-sample.fig">
          <title id="_7_0_537">Moving parts and message flow of the echo
          example</title><mediaobject id="_7_0_538">
            <imageobject id="_7_0_539">
              <imagedata width="600" fileref="figures/svgtest.svg" id="_7_0_540"/>
            </imageobject>
          </mediaobject>
        </figure></para><para id="_7_0_541">Listing <xref id="_7_0_542" linkend="ch02.echo-sample.lis"/> provides the full configuration for
      this example. As an astute reader, you'll quickly notice that there's no
      bridge component. This is because a service uses a bridge component
      implicitly <indexterm><primary>bridge component</primary><secondary>implicit</secondary></indexterm>if none is configured. Except for this subtlety, the
      configuration file is pretty straightforward. Note how the specific
      attributes on the different elements help to make the configuration
      self-explanatory.</para>
        <example id="ch02.echo-sample.lis">
          <title id="_7_0_543">The echo example XML configuration<!--cueballs in code and text--></title><programlisting id="_7_0_544" xml:space="preserve"><codelink file="codelistings/codenolinkend.txt" commentStyle="XML"/></programlisting><calloutlist id="_7_0_545">

            <callout arearefs="ch06_echo-sample-con_cod ch06_echo-sample-con_cod2 ch06_echo-sample-con_coda" id="ch06.echo-sample-con.cor"><para id="_7_0_546">Defines and configures 
standard input connector</para></callout>

            <callout arearefs="ch06_echo-sample-ser_cod ch06_echo-sample-ser_coda" id="ch06.echo-sample-ser.cor"><para id="_7_0_547">The echo service</para></callout>
          </calloutlist>
        </example>
      <para id="_7_0_548">In example <co id="ch06_echo-sample-con_coda" />, we installed the Mule standalone server and at <co id="ch06_echo-sample-ser_coda" />
      downloaded the examples from this book's companion web site. So, at this
      point, you should be able to start this example. For this, go into the
      <filename>/chapter02/echo</filename> directory and run the
      <filename>echo-xml</filename> batch file that suits your OS. The output
      should be as shown here, with a version and a build number that match
      your Mule installation and with the host name of your machine <indexterm><primary>standalone server</primary><secondary>startup sequence</secondary></indexterm>:</para><informalexample><programlisting id="_7_0_554" xml:space="preserve"><codelink file="codelistings/codewithlinkend.txt" linkend="ne-setup"/></programlisting></informalexample><para id="_7_0_555">As prompted, enter something. Note that the first
      time a message gets dispatched to the outbound endpoint, Mule
      instantiates and connects the necessary dispatcher:</para><informalexample><programlisting id="_7_0_558" xml:space="preserve"><codelink file="codelistings/None.java" linkend="maybe-none" /></programlisting></informalexample><para id="_7_0_559">When you're tired of playing with the echo, stop the
      execution <indexterm><primary>standalone server</primary><secondary>stopping</secondary></indexterm>of the application with <code id="_7_0_560">control+C</code>. All the log entries you'll see scrolling       on your console will represent a normal and clean shutdown of the       ESB <indexterm><primary>standalone server</primary><secondary>shutdown sequence</secondary></indexterm>. The very last lines shown in the console should be like
      this:</para><informalexample><programlisting id="_7_0_563" xml:space="preserve">*********************************************************************
* The server is shutting down due to normal shutdown request        *
* Server started: 28/02/09 15:52                                    *
* Server shutdown: 28/02/09 15:53                                   *
*********************************************************************
&lt;-- Wrapper Stopped</programlisting></informalexample><para id="_7_0_564">Note how <code id="_7_0_565">control+C</code> has       been interpreted as a normal shutdown request. If the JVM were to exit       abruptly, for example because of a hard crash, the wrapper       script <indexterm><primary>standalone server</primary><secondary>wrapper script</secondary></indexterm>would restart the instance automatically.</para><para id="_7_0_566">Even if basic, this example has shown you what less
      than 20 lines of configuration can buy you in Mule. You also got the
      gist of the runtime environment of Mule, how it behaves at startup and
      shutdown times, and what it reports in the logs.</para><para id="_7_0_589">The Echo World example has given you some clues
      about the organization of the Spring XML configuration file.<footnote><para>The same example is also provided as a scripted configuration
          in <filename>echo-world/conf/echo-config.groovy</filename> if you're
          curious to discover this configuration approach as well.</para></footnote> Let's now broaden your view by exploring the structure of
      this configuration file.</para></sect1><sect1 id="_7_0_590">
      <title id="_7_0_591">The Spring XML configuration</title><para id="_7_0_592">The Spring configuration builder <indexterm><primary>Spring</primary><secondary>XML configuration builder</secondary></indexterm> <indexterm><primary>configuration</primary><secondary>Spring XML</secondary></indexterm> <indexterm><primary>XML configuration</primary><see>configuration</see></indexterm>relies on XML to enforce the correct syntax
      (well-formedness) and on XML Schema <indexterm><primary>XML Schema</primary><see>configuration</see></indexterm>to define the grammatical rules (validity). These rules
      define the usable elements<footnote id="_7_0_593">
          <para id="_7_0_594"><emphasis>Element</emphasis> as defined by the
          W3C DOM specification.</para></footnote> and where they can be used. These elements represent the
      different moving parts of the ESB and their configurable
      parameters.</para><para id="_7_0_595">Mule doesn't rely on a single monolithic schema to
      define all the configurable elements, but instead on several of
      them <indexterm><primary>configuration</primary><secondary>XML schema</secondary></indexterm>. One of these schemas defines the core elements and the
      general structure of the configuration file. Other elements are defined
      by optional additional schemas, such as the transport-specific ones. If
      you look at the first lines of listing <xref id="_7_0_596" linkend="ch02.echo-sample.lis"/>, you'll see that the core and the VM
      transport specific schemas are imported.</para><tip><title>Best practice</title><para>Always validate your XML configuration files before attempting
        to load them in Mule to simplify troubleshooting.</para></tip>

      <para id="_7_0_597">Figure <xref id="_7_0_598" linkend="ch02.gen-conf.fig"/> represents the elements defined by the
      core schema <indexterm><primary>configuration</primary><secondary>XML schema</secondary><tertiary>core</tertiary>
        </indexterm>. Note how the services, which are the main actors of a
      configuration, are lost in the bottom-right corner of the mind map. This
      gives you an idea of all the supporting common features and global
      elements you can declare in a configuration file. Throughout the book,
      you'll progressively learn more about each of these elements.</para><para>
        <figure id="ch02.gen-conf.fig">
          <title id="_7_0_602">Configuration structure defined by Mule's XML
          core schema</title><mediaobject id="_7_0_603">
            <imageobject id="_7_0_604">
              <imagedata fileref="figures/Ch1MissingData.svg" id="_7_0_605"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para><para id="_7_0_606">The Echo World configuration in listing <xref id="_7_0_607" linkend="ch02.echo-sample.lis"/> only has a few schema
      references and one global element (a connector). You can easily imagine
      that real-world configuration files declare many of these shared
      configuration artifacts to support the configuration of their services.
      In the examples coming in the next chapters, you'll often see such
      shared elements, like global endpoints or transformers. Some chapters
      will even be dedicated to some of these common elements, such as
      transaction managers or JMX agents.</para><para id="_7_0_608">For now, we'll consider these elements under several
      of their main characteristics. First we'll look at their main families,
      then how we can define configured values, and finally where to find the
      schemas that define them.</para><sect2 id="ch02.ele-fam.sec">
        <title id="_7_0_609">XML element families</title><para id="_7_0_610">Independent of their functions, we can
        conceptually distinguish three main families of elements <indexterm><primary>configuration</primary><secondary>families of elements</secondary></indexterm>in a Mule configuration: <itemizedlist id="_7_0_611">
            <listitem id="_7_0_612">
              <para id="_7_0_613">The specific elements</para></listitem><listitem id="_7_0_614">
              <para id="_7_0_615">The custom elements</para></listitem><listitem id="_7_0_616">
              <para id="_7_0_617">The Spring elements</para></listitem></itemizedlist></para><para id="_7_0_618">It's important to understand what you can expect
        from each of these to build a configuration file in the most efficient
        manner.</para><formalpara id="_7_0_619">
          <title id="_7_0_620">Specific elements</title><para id="_7_0_621">The specific elements <indexterm><primary>configuration</primary><secondary>specific elements</secondary></indexterm>are the most expressive configuration elements
          available, insofar as they constitute the domain-specific language
          of Mule <indexterm><primary>Mule</primary><secondary>domain specific language</secondary></indexterm> <indexterm><primary>domain specific language</primary></indexterm>. As such, these elements and their attributes are
          characterized by highly specific names. Another characteristic is
          that they intrinsically refer to predefined concrete
          implementations: they're used to express all the configuration
          elements that aren't custom-made. This is why no class name comes
          into play when using this kind of configuration element. A benefit
          of this is the isolation your configuration gets from the internals
          of Mule's implementation: if a class is renamed, your configuration
          won't be affected.</para></formalpara>

        <para id="_7_0_623">The Mule core and each transport or module you
        include in your configuration will contribute such specific elements.
        Table <xref id="_7_0_624" linkend="ch02.spec-el.tab"/> is a
        nonexhaustive list<footnote id="_7_0_625">
            <para id="_7_0_626">There are more XML elements defined in these
            schemas; only the most notable ones are listed here.</para></footnote> of these elements as defined by a few Mule XML
        schemas.</para><table id="ch02.spec-el.tab">
          <title id="_7_0_627">Specific elements defined by some Mule
          schemas</title><tgroup cols="3" id="_7_0_628">
            <thead id="_7_0_629">
              <row id="_7_0_630">
                <entry id="_7_0_631"><para>Schema</para></entry>

                <entry id="_7_0_632">
                  <para id="_7_0_633">Elements defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_635"><para>Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_636">
              <row id="_7_0_637">
                <entry id="_7_0_638"><para>Mule Core</para></entry>

                <entry id="_7_0_639">
                  <para>
                  <variablelist>
                     <varlistentry>
                         <term>Models</term>
                         <listitem>This would be the definition of models.</listitem>
                     </varlistentry>
                     <varlistentry>
                     	<term>Transformers</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Routers</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Filters</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Components</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Security manager</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Exception strategies</term>
                     </varlistentry>
                     <varlistentry>
                     	<term>Transaction manager</term>
                     </varlistentry>
                  </variablelist>
                  </para>
                  
                  
                  </entry>

                <entry id="_7_0_651">
                  <informalexample id="_7_0_653"><programlisting id="_7_0_654" xml:space="preserve">&lt;object-to-string-transformer
                  name="ObjectToString"/&gt;</programlisting></informalexample>
                  <para id="_7_0_655">Defines a global object-to-string
                  transformer named <code>ObjectToString</code>. <indexterm><primary>object-to-string-transformer</primary></indexterm></para><informalexample><programlisting xml:space="preserve">&lt;global-property name="smtp.username"
  value="jqdoe" /&gt;</programlisting></informalexample>
                  <para>Defines a global property named
                  <code>smtp.username</code>, whose value is                   <code>jqdoe</code>. <indexterm><primary>global-property</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_656">
                <entry id="_7_0_657"><para>HTTP Transport</para></entry>

                <entry id="_7_0_658">
                  <para id="_7_0_659">HTTP connector</para><para id="_7_0_660">HTTP endpoint</para><para id="_7_0_661">REST service component</para><para id="_7_0_662">HTTP request and response
                  transformers</para></entry>

                <entry id="_7_0_663">
                  <informalexample id="_7_0_665"><programlisting id="_7_0_666" xml:space="preserve">&lt;http:polling-connector name="pollingHttp"
              pollingFrequency="3000"/&gt;</programlisting></informalexample>
                  <para id="_7_0_667">Defines an HTTP connector named
                  <code>pollingHttp</code>, which will be used for polling a                   URL every three seconds. <indexterm><primary>polling-connector</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_668">
                <entry id="_7_0_669"><para>XML Module</para></entry>

                <entry id="_7_0_670">
                  <para id="_7_0_671">XML transformers</para><para id="_7_0_672">XML routers</para><para id="_7_0_673">XML filters</para></entry>

                <entry id="_7_0_674">
                  <informalexample id="_7_0_676"><programlisting id="_7_0_677" xml:space="preserve">&lt;xm:xslt-transformer name="DocBook2FO"
         xsl-file="db2fo.xsl"/&gt;</programlisting></informalexample>
                 <para id="_7_0_678">Defines an XSL-T transformer named
                  <code>DocBook2FO</code>, which uses the templates defined in                   <code>db2fo.xsl</code>. <indexterm><primary>xslt-transformer</primary></indexterm></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <formalpara id="_7_0_679">
          <title id="_7_0_680">Custom elements</title><para id="_7_0_681">Custom elements <indexterm><primary>configuration</primary><secondary>custom elements</secondary></indexterm>constitute the Mule-oriented extension points of a
          configuration. They mainly allow you to use custom implementations
          or Mule classes for which no specific element has been created.
          These extension points are available for core Mule artifacts and
          also for some transports and modules. Custom elements usually rely
          on a fully qualified class name parameter to locate your custom
          code. They also provide a means to pass the property values your
          class needs to be properly configured. Table <xref id="_7_0_682" linkend="ch02.cust-el.tab"/> shows a few examples of these custom
          elements.</para></formalpara>

        <table id="ch02.cust-el.tab">
          <title id="_7_0_683">Custom elements defined by some Mule
          schemas</title><tgroup cols="3" id="_7_0_684">
            <thead id="_7_0_685">
              <row id="_7_0_686">
                <entry id="_7_0_687"><para>Schema</para></entry>

                <entry id="_7_0_688">
                  <para id="_7_0_689">Elements defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_691"><para>Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_692">
              <row id="_7_0_693">
                <entry id="_7_0_694"><para>Mule Core</para></entry>

                <entry id="_7_0_695">
                  <para id="_7_0_696">Custom transformer</para><para id="_7_0_697">Custom router</para><para id="_7_0_698">Custom filter</para><para id="_7_0_699">Custom entry point resolver</para><para id="_7_0_700">Custom security and encryption
                  providers</para><para id="_7_0_701">Custom exception strategy</para><para id="_7_0_703">Custom transaction manager</para></entry>

                <entry id="_7_0_704">
                  <informalexample id="_7_0_706"><programlisting id="_7_0_707" xml:space="preserve">&lt;custom-transformer name="NameStringToChatString"
   class=
"org.mule.example.hello.NameStringToChatString"/&gt;</programlisting></informalexample>
                  <para id="_7_0_708">Defines a custom transformer named
                  <code>NameStringToChatString</code> as an instance of the specified class. <indexterm><primary>custom-transformer</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_709">
                <entry id="_7_0_710"><para>TCP Transport</para></entry>

                <entry id="_7_0_711"><para>Custom protocol</para></entry>

                <entry id="_7_0_712">
                  <informalexample id="_7_0_714"><programlisting id="_7_0_715" xml:space="preserve">&lt;tcp:custom-protocol
class="org.mule.CustomSerializationProtocol"/&gt;</programlisting></informalexample>
                  <para id="_7_0_716">Defines a custom TCP protocol as an
                  instance of the specified class. <indexterm><primary>custom-protocol</primary></indexterm></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para id="_7_0_725">Though it's possible to do what a specific XML
        element can do using a custom XML element, this should be avoided for
        two main reasons. The first is because you'll become coupled to a
        particular implementation in Mule itself: if a new class is created
        and used by the specific element, your custom one will keep
        referencing the old one. The second is because you'll lose the benefit
        of the strongly typed (schema validated) and highly expressive
        attributes defined on the specific elements.</para><tip><title>Best practice</title><para>If possible, try to use a specific configuration element
          instead of custom one.</para></tip>

        <sect3 id="_7_0_726">
          <title id="_7_0_727">Spring elements</title><para id="_7_0_728">Thanks to the support of a few core Spring
          schemas<indexterm><primary>configuration</primary><secondary>Spring elements</secondary></indexterm>, Mule can accept Spring elements <indexterm><primary>Spring</primary><secondary>elements in configuration</secondary></indexterm>in its configuration. Spring elements are used to
          instantiate and configure any object that'll be used elsewhere in
          the configuration, where they'll usually be injected in standard
          Mule elements. They're also used to easily construct configuration
          parameters such as lists or maps. Finally, they allow configuration
          modularity through the support of the import element (see section
          <xref id="_7_0_729" linkend="ch02.conf-mod.sec"/>). Table <xref id="_7_0_730" linkend="ch02.spring-el.tab"/> shows a few examples
          of these Spring elements. Note how the
          <code>spring:beans</code> <indexterm><primary>Spring</primary><secondary>beans</secondary></indexterm>element opens the door to the usage of any Spring           schema (in this example we use the <code>util</code> one).</para>
          <table id="ch02.spring-el.tab">           <title id="_7_0_731">Elements defined by the supported Spring
          schemas</title><tgroup cols="3" id="_7_0_732">
            <thead id="_7_0_733">
              <row id="_7_0_734">
                <entry id="_7_0_735"><para>Schema</para></entry>

                <entry id="_7_0_736">
                  <para id="_7_0_737">Elements defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_739"><para>Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_740">
              <row id="_7_0_741">
                <entry id="_7_0_742"><para>Spring Beans</para></entry>

                <entry id="_7_0_743">
                  <para id="_7_0_744">Beans</para><para id="_7_0_745">Bean</para><para id="_7_0_746">Property</para></entry>

                <entry id="_7_0_747">
                  <informalexample id="_7_0_749"><programlisting id="_7_0_750" xml:space="preserve">&lt;spring:bean name="cfAMQ"
  class=
  "org.apache.spring.ActiveMQConnectionFactory"&gt;
  &lt;spring:property name="brokerURL"
    value="tcp://localhost:61616"/&gt;
&lt;/spring:bean&gt;</programlisting></informalexample>
                  <para id="_7_0_751">Instantiates an ActiveMQ connection
                  factory, configured with the specified broker URL parameter
                  and named <code>cfAMQ</code>. <indexterm><primary>Spring</primary><secondary>property</secondary></indexterm></para><para id="_7_0_752">
                    </para><informalexample id="_7_0_753"><programlisting id="_7_0_754" xml:space="preserve">&lt;spring:beans&gt;
  &lt;spring:import
     resource="classpath:applicationContext.xml" /&gt;
&lt;/spring:beans&gt;</programlisting></informalexample>
                 <para id="_7_0_755">Imports a Spring application context
                  from the classpath. <indexterm><primary>Spring</primary><secondary>import</secondary></indexterm></para><para>
                    </para><informalexample><programlisting xml:space="preserve">&lt;inbound-endpoint ref="globalEndpoint"&gt;
  &lt;properties&gt;
    &lt;spring:entry key="valueList"&gt;
      &lt;util:list&gt;
        &lt;spring:value&gt;value1 and others&lt;/spring:value&gt;
        &lt;spring:value&gt;value2&lt;/spring:value&gt;
      &lt;/util:list&gt;
    &lt;/spring:entry&gt;
  &lt;/properties&gt;
&lt;/inbound-endpoint&gt;</programlisting></informalexample>
                  <para>Sets a list property on an endpoint. <indexterm><primary>Spring</primary><secondary>util schema</secondary></indexterm></para></entry>
              </row>

              <row id="_7_0_756">
                <entry id="_7_0_757"><para>Spring Context</para></entry>

                <entry id="_7_0_758"><para>Property placeholder resolver</para></entry>

                <entry id="_7_0_759">
                  <informalexample id="_7_0_761"><programlisting id="_7_0_762" xml:space="preserve">&lt;context:property-placeholder 
   location="node.properties"/&gt;</programlisting></informalexample>
                  <para id="_7_0_763">Activates the replacement of placeholders, resolved against the specified properties file.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
	<para>When you start writing your own
          configuration files, you'll quickly realize how valuable this is.
          Whenever you configure a Mule object, the question of its default
          configuration values will arise. What would usually take a visit to
          the JavaDoc page of the object will now require only a glance at the
          default values for the different attributes supported by the XML
          element that represent the object (provided you use a decent tool).</para>
</sect3>

<sect3><title>A sect3 should come last</title>

        <para id="_7_0_765">Besides configuration extension, Spring elements
        also grant access to the framework itself, making possible the usage
        of advanced features such as AOP. Though you can do a lot in Mule
        without deferring to Spring, getting acquainted with this framework
        will allow you to better grasp the core on which Mule is built. If
        you're unfamiliar with Spring or would like to learn more about it, we
        strongly recommend reading <emphasis>Spring in
        Action</emphasis> <indexterm><primary>Spring in Action</primary></indexterm>from Manning Publications Co. (Walls and
        Breidenbach).</para><para id="_7_0_766">You've now learned to recognize the different
        families of XML elements you'll have to deal with and what you can
        expect from them. XML elements without values specific to your
        configuration are useless. Let's now see how you'll set these
        different values in your own configuration files.</para>
        </sect3>
        
        </sect2><sect2 id="ch02.config-values.sec">
        <title id="_7_0_767">Configured values</title><para id="_7_0_768">In a Mule configuration, values are seldom stored
        as text nodes; they're mainly stored as attributes of XML elements.
        The main exceptions are text-rich properties such as documentation or
        script elements. This makes the configuration easier to read, format,
        and parse, as attributes are less prone to being disrupted by unwanted
        whitespaces. These attributes are strongly typed, with data
        types <indexterm><primary>configuration</primary><secondary>data types</secondary></indexterm>defined by the XML Schema standard.</para><para id="_7_0_769">We'll consider these configured values under their
        most notable traits:</para><itemizedlist id="_7_0_770">
          <listitem id="_7_0_771">
            <para id="_7_0_772">Default values</para></listitem><listitem id="_7_0_773">
            <para id="_7_0_774">Enumerated values</para></listitem><listitem><para>Expressions</para></listitem><listitem id="_7_0_775">
            <para id="_7_0_776">Property placeholders</para></listitem><listitem id="_7_0_777">
            <para id="_7_0_778">Names and references</para></listitem></itemizedlist>

        <sect3 id="_7_0_779">
          <title id="_7_0_780">Default values</title><para id="_7_0_781">Using attributes to hold values enables the
          definition of default values<indexterm><primary>configuration</primary><secondary>default values</secondary></indexterm>. Mule schemas take great care to define default
          values wherever possible. When you start writing your own
          configuration files, you'll quickly realize how valuable this is.
          Whenever you configure a Mule object, the question of its default
          configuration values will arise. What would usually take a visit to
          the JavaDoc page of the object will now require only a glance at the
          default values for the different attributes supported by the XML
          element that represent the object (provided you use a decent tool;
          see chapter <xref id="_7_0_782" linkend="dev.ch"/>).</para></sect3>

        <sect3 id="_7_0_783">
          <title id="_7_0_784">Enumerated values</title><para id="_7_0_785">On top of being strongly typed, some attributes
          define an enumeration of possible configuration values <indexterm><primary>configuration</primary><secondary>enumerated values</secondary></indexterm>. This greatly reduces the risk of introducing a bogus
          value that would only be caught later on at runtime. This also
          provides valuable information about the intent of the parameter and
          the abilities of the configured object.</para></sect3>

        <sect3><title>Expressions</title><para>Mule's expression evaluation framework offers the capacity to
          define configuration values that are evaluated dynamically at
          runtime. With simple attribute values of the form
          <code>#[evaluator:expression]</code>, it is possible to access           almost any data from the current message being processed or the Mule           instance itself. Please refer to appendix <xref linkend="expreval.anx"/> for more information about this powerful           framework.</para></sect3>

        <sect3 id="_7_0_786">
          <title id="_7_0_787">Property placeholders</title><para id="_7_0_788">An important aspect of any configuration file is
          the capacity to externalize certain values that can change at
          runtime. These values are called
          <emphasis>properties</emphasis> <indexterm><primary>configuration</primary><secondary>properties</secondary></indexterm> <indexterm><primary>property placeholders</primary></indexterm>. They're generally used to define
          environment-specific parameters such as credentials, port numbers,
          or paths. It's possible to use such properties in lieu of fixed
          values in any attribute of a Mule configuration. The property is
          then referred to by its name using a special placeholder syntax.
          This is done using the classic Ant notation <indexterm><primary>Ant notation</primary></indexterm>, as shown: </para>
          <informalfigure id="_7_0_789">
              <mediaobject id="_7_0_790">
                <imageobject id="_7_0_791">
                  <imagedata width="609" height="151" fileref="figures/referencesHH.png" id="_7_0_792"/>
                </imageobject>
              </mediaobject>
            </informalfigure><para>These properties are defined either as global
          ones in the Mule configuration <indexterm><primary>properties</primary><secondary>global</secondary><seealso>global-property</seealso></indexterm>, in a standard Java properties file <indexterm><primary>properties</primary><secondary>file</secondary></indexterm>or in JVM system properties <indexterm><primary>properties</primary><secondary>system</secondary></indexterm>. For the last two options, Spring's property
          placeholder resolver <indexterm><primary>Spring</primary><secondary>property placeholder resolver</secondary></indexterm>(shown in table <xref id="_7_0_793" linkend="ch02.spring-el.tab"/>) takes care of injecting the
          properties value in your configuration.</para>

        <tip id="_12_0_3664">
          <title id="_12_0_3665">Environment properties</title><para id="_12_0_3666">As with any other application, you'll have to
          externalize environment-specific values in properties files. These
          are usually passwords, remote service URLs, port numbers, time-outs,
          or cron expressions. With Spring XML configurations, a good practice
          is leveraging Spring's <code id="_12_0_3667">PropertyPlaceholderConfigurer <indexterm><primary>PropertyPlaceholderConfigurer</primary></indexterm></code> to load properties from several files on the           classpath. The idea is to define reasonable defaults for the
          development environment in a properties file embedded in the
          deployable itself, and to override <indexterm><primary>properties</primary><secondary>override</secondary></indexterm>these values with others defined in an
          environment-specific property file placed also on the classpath, but
          outside of the deployable. This is demonstrated here:<!--Typesetting: note code continuation arrow [CA] below--></para><informalexample id="_12_0_3668"><programlisting id="_12_0_3669">&lt;context:property-placeholder
              location="classpath:META-INF/default.props, [CA] \
              classpath:override.props" /&gt;</programlisting></informalexample><para id="_12_0_3670">This configuration element imports values from
          classpath files <filename id="_12_0_3671">META-INF/default.props</filename> and from <filename id="_12_0_3672">override.props</filename>. The latter can be left
          empty in development and tuned to use correct values in test or
          production environments. This construct also supports overriding
          with Java system properties: if a system property is defined, it'll
          take precedence over a property of the same name defined in one of
          these files.</para></tip>
</sect3>
        <sect3 id="_7_0_805">
          <title id="_7_0_806">Names and references</title><para id="_7_0_807">Being able to have elements that reference other
          elements is an essential aspect of a Mule configuration file. This
          is achieved by using name and reference attributes <indexterm><primary>configuration</primary><secondary>names and references</secondary></indexterm>. Most of the elements can receive a name through this
          mechanism. References can sometimes be multivalued. In that case,
          whitespace is used to separate the different names that are referred
          to. The following demonstrates an inbound endpoint that refers to a
          chain of four transformers simply by listing their
          names:</para><informalfigure id="_7_0_808">
              <mediaobject id="_7_0_809">
                <imageobject id="_7_0_810">
                  <imagedata fileref="figures/propertyPlaceholderHH.png" id="_7_0_811"/>
                </imageobject>
              </mediaobject>
            </informalfigure><para>You now know the secrets to setting values in
          your XML configurations. We'll now look at one thing that may still
          puzzle you: the location of all these different schemas.</para></sect3>
      </sect2><sect2 id="_7_0_812">
        <title id="_7_0_813">Schema locations</title><para id="_7_0_814">You might be wondering where to get an up-to-date
        list of all the available schemas you can use in your configurations.
        This section will do better than give you this list: it'll allow you
        to figure out by yourself the right schema reference to use for any
        Mule library you decide to use.</para><para id="_7_0_815">When you look at the declaration in listing <xref id="_7_0_816" linkend="ch02.echo-sample.lis"/>, you might be
        wondering if Mule will connect to the Internet to download the
        different schemas from the specified locations. Of course it doesn't.
        Each library (transport or module) embeds the schemas it
        needs <indexterm><primary>configuration</primary><secondary>XML schema</secondary><tertiary>transport</tertiary>
          </indexterm>. Mule leverages the resource resolver mechanism of
        Spring <indexterm><primary>Spring</primary><secondary>resource resolver</secondary></indexterm>to 'redirect' the public HTTP URIs into ones that are
        internal to the JAR file <indexterm><primary>configuration</primary><secondary>XML schema</secondary><tertiary>in JAR files</tertiary>
          </indexterm>. How is this mechanism configured? To discover it, fire
        up your favorite archiving utility or IDE and open the library you
        want to use. There should be a directory named
        <filename>META-INF</filename>. After opening it, you should see
        something similar to the screen shot shown in figure <xref id="_7_0_817" linkend="ch02.schema-loc.fig"/>.<figure id="ch02.schema-loc.fig">
            <title id="_7_0_818">Locating the XML schema of the VM
            transport</title><mediaobject id="_7_0_819">
              <imageobject id="_7_0_820">
                <imagedata fileref="figures/independentConfigurations.gif" id="_7_0_821"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_822">The schema you're looking for is in the <filename id="_7_0_823">META-INF</filename> directory and is named after the
        transport or module name, prefixed with <code>mule-</code>. Figure         <xref id="_7_0_824" linkend="ch02.schema-loc.fig"/> shows that in the         VM transport, the schema is named <filename id="_7_0_825">mule-vm.xsd</filename>. Some transports have several         schemas, one per variation of the main transport (such as HTTP and
        HTTPS). The target namespace of the schema you're looking for is
        declared on the root element. Listing <xref id="_7_0_826" linkend="ch02.vm-trans-root.lis"/> shows the root element of the VM
        transport schema.</para><example id="ch02.vm-trans-root.lis">
            <title id="_7_0_827">The target namespace to use in configuration
            files is defined in the schema of each Mule library.</title><programlisting id="_7_0_828" xml:space="preserve"><codelink file="codelistings/codeJava.txt" /></programlisting><calloutlist>
            <callout arearefs="testjavacomment">This is a test callout.</callout>
            </calloutlist></example>
            
            <example id="ch02.vm-trans-root.lis">
            <title id="_7_0_827">This example tests the EL embedded</title><programlisting id="_7_0_828" xml:space="preserve"><codelink file="codelistings/codeEl.txt" /></programlisting></example>
            
            
            
            <para id="_7_0_829">By now you should be anxious to know where the
        schema location <indexterm><primary>configuration</primary><secondary>XML schema</secondary><tertiary>location</tertiary>
          </indexterm>is defined. Using the right location is important in
        order for the 'redirection' mechanism to kick in and allow Mule to
        validate and load your configuration file. This mechanism is
        configured by the file named <filename id="_7_0_830">spring.schemas</filename>, which is located alongside
        the library schema. You can see this file in figure <xref id="_7_0_831" linkend="ch02.schema-loc.fig"/>. The content of this
        file is a simple mapping between the remote schema location and the
        archive file to use for it, as shown:<informalfigure id="_7_0_832">
            <mediaobject id="_7_0_833">
              <imageobject id="_7_0_834">
                <imagedata fileref="figures/schemaLocationHH.gif" id="_7_0_835"/>
              </imageobject>
            </mediaobject>
          </informalfigure></para><para id="_7_0_836">The schema location you want to use is on the left
        of the equal sign. Bear in mind that because properties files require
        you to escape colons, the backslash in front of the equal sign should
        be omitted if you copy and paste the location directly into your
        configuration file. With the target namespace and the schema location
        in hand, you should now be able to add the VM transport schema to your
        configuration file. Listing <xref id="_7_0_837" linkend="ch02.vm-conf-root.lis"/> shows you what you should have come
        up with.</para><example id="ch02.vm-conf-root.lis">
            <title id="_7_0_838">The root element of a Mule configuration that
            uses the VM transport<!--cueballs in code and text--></title><programlisting id="_7_0_839" xml:space="preserve"><codelink file="codelistings/codeXML.txt" linkend="servlet_DispatcherServlet" commentStyle="XML" /></programlisting><calloutlist id="_7_0_840">
              <callout arearefs="ch06.root-vm.cod" id="ch06.root-vm.cor">
                <para id="_7_0_841">Defines VM transport namespace</para></callout>

              <callout arearefs="ch06.root-vm-loc.cod" id="ch06.root-vm-loc.cor">
                <para id="_7_0_842">Location of VM transport schema</para></callout>
            </calloutlist>
          </example><para id="_7_0_843">Throughout this chapter, we've referred to the
        Mule core schema. If you look for it in
        <filename>mule-core.jar</filename> <indexterm><primary>mule-core.jar file</primary></indexterm>, you'll be disappointed. It's in fact located in
        <filename>mule-module-spring-config.jar</filename> <indexterm><primary>mule-module-spring-config.jar file</primary></indexterm>. Why there and not in the core JAR? Because using
        Spring XML is one possibility for building a Mule configuration. As we
        said in the introduction, there are other ways, such as
        scripting.</para><tip id="_7_0_844">
          <title id="_7_0_845">My valid configuration doesn't load!</title><para id="_7_0_846">It's possible to create a configuration that
          refers to all the right schemas and is well formed and valid, but
          still doesn't load. If this happens to you and you get a cryptic
          message like the following <indexterm><primary>configuration</primary><secondary>XML schema</secondary><tertiary>namespace handler</tertiary>
            </indexterm> <indexterm><primary>NamespaceHandler</primary></indexterm>:</para><informalexample id="_7_0_847"><programlisting id="_7_0_848" xml:space="preserve">Configuration problem: Unable to locate
NamespaceHandler for namespace
[http://www.mulesource.org/schema/mule/xyz/2.2]</programlisting></informalexample><para>Then get ready for a 'duh' moment. This means
          you've forgotten to add to your classpath the Mule library that
          defines the namespace handler required to load configuration
          elements in said namespace. Watch out for missing transport or
          module JARs.</para></tip>

        <para id="_7_0_849">By now, you're certainly eager to rush to your
        keyboard and start building your own configurations. Before that, we'd
        like to introduce the notion of modular configurations. This will help
        you tame the complexity that may arise in your configurations when
        your projects start expanding.</para><sidebar><title>Another hint</title><para>Consider also reading chapter, where
          we discuss the development tools you'll need, before starting a Mule
          project.</para></sidebar>
      </sect2></sect1><sect1 id="ch02.conf-mod.sec">
      <title id="_7_0_850">Configuration modularity</title><para id="_7_0_851">Have you ever had to wade through pages and pages of
      configuration, trying to sort things out and find your way around? As
      your integration projects grow and multiply, there's a risk that your
      configuration files may become bloated or redundant, hence hard to read,
      test, and maintain. Fortunately, the configuration mechanism of Mule
      allows you to relieve the ails of a monolithic configuration by
      modularizing it <indexterm><primary>configuration</primary><secondary>modularity</secondary></indexterm>.</para><important><title>Best practice</title><para>Modularize your configuration files to make them easier to read
        and simplify their maintenance.</para></important>

      <para id="_7_0_852">Cutting a configuration into several parts
      encourages the following <indexterm><primary>configuration</primary><secondary>modularity</secondary><tertiary>advantages</tertiary>
        </indexterm>:<itemizedlist id="_7_0_853">
          <listitem id="_7_0_854">
            <para id="_7_0_855">Reuse <indexterm><primary>configuration</primary><secondary>reuse</secondary></indexterm>of common artifacts across several
            configurations</para></listitem><listitem id="_7_0_856">
            <para id="_7_0_857">Extraction of environment-dependent <indexterm><primary>configuration</primary><secondary>environment dependent</secondary></indexterm>configuration artifacts</para></listitem><listitem id="_7_0_858">
            <para id="_7_0_859">Isolation of functional aspects that become
            testable in isolation <indexterm><primary>configuration</primary><secondary>testability</secondary></indexterm></para></listitem></itemizedlist></para><para id="_7_0_860">There are different approaches that can be used when
      modularizing a configuration. In the following sections, we'll detail
      these strategies: <itemizedlist id="_7_0_861">
          <listitem id="_7_0_862">
            <para id="_7_0_863">Independent configurations</para></listitem><listitem id="_7_0_864">
            <para id="_7_0_865">Inherited configurations</para></listitem><listitem id="_7_0_866">
            <para id="_7_0_867">Imported configurations</para></listitem><listitem id="_7_0_868">
            <para id="_7_0_869">Heterogeneous configurations</para></listitem></itemizedlist></para><para id="_7_0_870">Of course, you can combine them together. At the end
      of the day, the objective of this discussion is to give you a hint of
      the possibilities and let you establish the configuration organization
      that best fits your project size and needs.</para><warning><title>Using an existing context</title><para>In section 7.1, we'll discuss another
        handy option: using an existing Spring context as the parent context
        of your Mule configuration. Because this isn't done at configuration
        level, we won't detail this approach here.</para></warning><sect2 id="_7_0_871">
        <title id="_7_0_872">Independent configurations</title><para id="_7_0_873">As shown in figure <xref id="_7_0_874" linkend="ch02.indep-conf.fig"/>, a Mule instance can load several
        independent configuration files side by side <indexterm><primary>configuration</primary><secondary>modularity</secondary><tertiary>independent files</tertiary>
          </indexterm>. In this example, Mule will use two Spring XML
        configuration builders to instantiate, configure, and wire together
        the elements defined in both XML configuration files. As you can see,
        the environment-dependent properties have been exported in an external
        file, loaded from the instance-specific configuration file.<figure id="ch02.indep-conf.fig">
            <title id="_7_0_875">A Mule instance can load independent XML
            configuration files and properties files.  We also want to test out a multi-line figure caption.</title><mediaobject id="_7_0_876">
              <imageobject id="_7_0_877">
                <imagedata fileref="figures/inheritedConfigurations.gif" width="442" id="_7_0_878"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_879">This approach is well suited for simple scenarios,
        where there's a loose coupling between the common and
        instance-specific elements. It allows a fair level of reuse, as global
        elements such as connectors, transformers, or endpoints can be shared
        with several instance-specific configurations.</para><para id="_7_0_880">The main drawback of using independent
        configurations is that the instance-specific configuration doesn't
        strongly express its need to run alongside the common configuration.
        If the shared elements aren't used immediately, like transformers, you
        can start the Mule instance without the required common configuration
        and start having issues only later on at runtime.</para><para id="_7_0_881">Using inherited configurations alleviates this
        problem.</para></sect2><sect2 id="_7_0_882">
        <title id="_7_0_883">Inherited configurations</title><para id="_7_0_884">The concept of inherited configurations is
        illustrated in figure <xref id="_7_0_885" linkend="ch02.inher-conf.fig"/>. The main idea is to express a formal
        parent-child dependency between two configurations <indexterm><primary>configuration</primary><secondary>modularity</secondary><tertiary>inheritance</tertiary>
          </indexterm>. By strongly expressing this dependency, you'll have
        the guarantee at boot time that no configuration file has been omitted
        (unlike the behavior you get with side-by-side independent
        configurations as described in the previous section).<figure id="ch02.inher-conf.fig">
            <title id="_7_0_886">Models can be inherited, leading to enforced
            hierarchies of configuration files.</title><mediaobject id="_7_0_887">
              <imageobject id="_7_0_888">
                <imagedata fileref="figures/inheritedHeterogeneousConfigurations.gif" id="_7_0_889"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_890">Inheritance can only be defined between models:
        this is why the parent and child models are represented. Because a
        model can be empty, this inheritance approach is suitable even if the
        common configuration doesn't have any model elements to share. It's
        also good to know that several different models can inherit from the
        same parent. The modularization can therefore span several
        configuration files.</para><para id="_7_0_891">How is this inheritance expressed? Simply by using
        the same name for the parent and child models and by flagging the
        child as being an heir <indexterm><primary>model</primary><secondary>inheritance</secondary></indexterm>, as shown here:</para><informalexample id="_7_0_892"><programlisting id="_7_0_893" xml:space="preserve">&lt;model name="myConfig"&gt;
&lt;model name="myConfig" inherit="true"&gt;</programlisting></informalexample><para id="_7_0_894">In this configuration sample, the parent model
        doesn't have an <code>inherit</code> attribute, which defaults to         false when absent, and the child model has the attribute set to         <code>true</code>.</para></sect2><sect2 id="_7_0_895">
        <title id="_7_0_896">Imported configurations</title><para id="_7_0_897">As briefly discussed in section <xref id="_7_0_898" linkend="ch02.ele-fam.sec"/>, Spring can be leveraged
        to instantiate and configure any infrastructure or custom bean you
        need for your Mule instance. For example, Spring can perform JNDI
        lookups or wire your business logic beans together. After time, your
        Spring configuration may grow to the point that it starts to clutter
        your Mule configuration. Or you might decide that part of your Spring
        configuration is reusable. At this point, extracting your Spring beans
        to a dedicated application context file would be the right thing to
        do. Figure <xref id="_7_0_899" linkend="ch02.impor-conf.fig"/> shows
        a situation where such shared application contexts have been created
        and are used by a hierarchy of Mule configurations.<figure id="ch02.impor-conf.fig">
            <title id="_7_0_900">Imported Spring application context files can
            complement a hierarchy of Mule configurations.</title><mediaobject id="_7_0_901">
              <imageobject id="_7_0_902">
                <imagedata fileref="figures/inheritedSpringConfigurations.gif" id="_7_0_903"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_904">You can easily import external Spring application
        context files from your Mule configuration files. <indexterm><primary>configuration</primary><secondary>modularity</secondary><tertiary>importing files</tertiary>
          </indexterm><footnote><para>Interactions between Mule and Spring configurations are
            further discussed in <xref linkend="ch07.embedded.sec"/>.</para></footnote> The following illustrates how <code id="_7_0_905">instance-conf.xml</code>, shown in figure <xref id="_7_0_906" linkend="ch02.impor-conf.fig"/>, would import its         Spring <indexterm><primary>Spring</primary><secondary>import</secondary></indexterm>context file:</para><informalexample id="_7_0_907"><programlisting id="_7_0_908" xml:space="preserve">&lt;spring:beans&gt;
    &lt;spring:import resource="instance-beans.xml" /&gt;
&lt;/spring:beans&gt;</programlisting></informalexample><para id="_7_0_909">Refer to Spring's documentation for more
        information on the usage of the import element.</para></sect2><sect2 id="_7_0_910">
        <title id="_7_0_911">Heterogeneous configurations</title><para id="_7_0_912">In the introduction to this chapter, we evoked the
        possibility of configuring Mule with a scripting language. The tedious
        work of setting up the core runtime environment and all the
        boilerplate code this requires is usually enough to put off the
        bravest script aficionado. The good news is that there's a solution.
        It's possible to mix several styles of Mule configuration <indexterm><primary>configuration</primary><secondary>modularity</secondary><tertiary>mixed format</tertiary>
          </indexterm>in an instance. The example in figure <xref id="_7_0_913" linkend="ch02.heter-conf.fig"/> shows an instance that
        has been configured with a Groovy script and Spring XML configuration
        builders. By following this approach, you can declare all the global
        elements using the XML syntax and focus your scripted configuration on
        the services you need for your integration project.<figure id="ch02.heter-conf.fig">
            <title id="_7_0_914">Mule can use heterogeneous builders to load a
            hierarchy of configuration files written in different
            syntax.</title><mediaobject id="_7_0_915">
              <imageobject id="_7_0_916">
                <imagedata fileref="figures/jeditXsdAssist.png" id="_7_0_917"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_918">Since scripted configuration works at the bare
        metal level, you express the dependency to a parent by looking up the
        model you want to depend on. If in figure <xref id="_7_0_919" linkend="ch02.heter-conf.fig"/>, the common configuration defined a
        model named <code>commonModel</code>, the way the Groovy configuration <indexterm><primary>configuration</primary><secondary>Groovy</secondary></indexterm>would look it up and use it would be the
        following:</para><informalexample id="_7_0_920"><programlisting id="_7_0_921" xml:space="preserve">model = muleContext.registry.lookupModel("commonModel")
...
childService.model = model</programlisting></informalexample><para id="_7_0_922">As you can see, there's no child model <emphasis id="_7_0_923">per se</emphasis>. It's up to the service in the child
        model to actively register itself in the model defined in the common
        configuration.</para><para id="_7_0_924">We're sorry to report that after reading this
        section, you have no more excuses for building monolithic and
        kilometric configuration files. And if you've inherited such
        configurations, you should now have some pretty good ideas on how you
        could refactor them.</para></sect2></sect1><sect1 id="_7_0_925">
      <title id="_7_0_926">Summary</title><para id="_7_0_927">In this chapter, you've learned the general
      principles involved in configuring Mule. You've discovered the overall
      structure of the Spring XML configuration, its syntax, and the ways to
      define properties values. Several strategies for organizing your
      configuration files have been detailed: they'll allow you to grow your
      integration projects without getting lost in lengthy and monolithic XML
      files.</para><para id="_7_0_928">The scripted configuration mechanisms have been
      rapidly covered as well. It's up to you to decide on your syntax of
      choice for configuring Mule. By looking at the examples at the end of
      this chapter, you should have a fair idea of the efforts involved in the
      XML and scripted configuration options. In the rest of the book, all the
      examples will use the Spring XML syntax.</para><para id="_7_0_929">In many places, this chapter has referred you to
      other chapters. Without this crafty stratagem, this chapter would've had
      the size of the whole book. The coming chapters will look further into
      the details of the main Mule moving parts: endpoints, routers,
      transformers, and components. You'll learn about the main types of each
      and all the good they can do for you.</para><important id="_7_0_930">
        <title id="_7_0_931">Before we close...</title><para id="_7_0_932">We'd like to introduce you to Clood,
        Inc. <indexterm><primary>Clood, Inc.</primary><secondary>presentation</secondary></indexterm>, our fictional but promising startup specializing in
        the domain of value-added services for businesses hosting applications
        in the cloud. Blessed with a double O, our startup is bound for a
        great future and a significant IPO. On the technical side of things,
        Clood, Inc., decided to leverage Mule as our integration platform to
        support all the services (monitoring, deployment controls, identity
        management, DNS, and so on) we intend to offer to our clients.</para><para id="_7_0_933">We're happy to inform you that, always looking for
        a challenge and some stock options, you've decided to join us on this
        cloudy adventure. Throughout the rest of the book, we'll review some
        of our activities at Clood, Inc., and how we're using Mule to
        accomplish them.</para></important>
    </sect1></chapter>
</book>