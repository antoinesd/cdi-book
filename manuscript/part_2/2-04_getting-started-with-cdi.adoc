:sourcedir: ../../code/src/main/java

[[chap04-getting-started]]
== Getting started with CDI

As we saw, CDI in itself is a specification, that is an abstract concept, or a set of abstract concepts, described in a paper document. Aside of this document, there are several implementations that are there to give life to this specification.

What does this specification do? Well, it defines many things, many concepts, and the way those concepts interact between themselves. The interactions between those concepts are many, and to understand the overall, you need to know CDI well. Basically, to understand CDI, you need to have a good understanding of CDI, which is a good example of the chicken and egg problem.

So before deep diving in all these abstract and complex concepts, let us write a first, very simple application. This application will have a `beans.xml` file, an injection point, and we are going to run it in a Weld container. A Weld container is the piece of software we need to run a CDI application. Weld is an implementation of the CDI specification, it has a special status among all the existing implementations: it is the reference implementation.

include::2_04/2-04-01-writing-you-first.adoc[]
include::2_04/2-04-02-the-content-of-beans.adoc[]
include::2_04/2-04-03-bean-archive.adoc[]
include::2_04/2-04-04-concept-of-a-bean.adoc[]
include::2_04/2-04-05-where-do-we-go.adoc[]
include::2_04/2-04-06-injection-point.adoc[]




=== Producing home made beans

We can go in several directions from this point. Let us choose one: how can we tell CDI that is should not rely on the default instantiation of a bean to create an instance. Suppose we have a special process that we want to use to create our own instance of a bean.

This is where the notion or producer is used. CDI knows that it should set the value of a field because it is annotated with the `@Inject` annotation. We can also use a `@Produce` annotation to tell it how to create an instance of a given bean.

Let us show this on an example. Suppose that our `InMemoryPostRepository` needs a parameter to be built: namely the size of the underlying `HashMap` used to save our posts.

[[app_listing]]
.The `InMemoryPostRepository` class with no empty constructor
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

The main difference between this version of this class and the previous one is that CDI cannot build it on its own. Why? Because the empty constructor that was present in the previous version is not here anymore. So CDI cannot rely on the Java reflection API to build instances of this bean. And indeed, if we run our example again, we get this error message.

[[app_listing]]
.Error met with a bean with no empty constructor
[source,txt]
----
Exception in thread "main" org.jboss.weld.exceptions.DeploymentException: WELD-001408: Unsatisfied dependencies for type PostRepository with qualifiers @Default
  at injection point [BackedAnnotatedField] @Inject private chap04.service.PostServiceImpl.postRepository
  at chap04.service.PostServiceImpl.postRepository(PostServiceImpl.java:0)
----

Since CDI could not find a way to build an instance of the `PostRepository` type, it could not build the `PostService` neither.

How can we solve that? In fact there are three ways of solving it.

==== Annotated constructor

First, we can annotate the constructor CDI should use with the `@Inject` annotation.

[[app_listing]]
.Annotating the constructor of the `InMemoryPostRepository` class
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    @Inject
    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

Of course, if our class has several constructors, only one should be annotated. If more than one constructor is annotated, then CDI will raise an error.

CDI will then call this constructor to build an instance of `InMemoryPostRepository`, and will need values for the parameters of this constructor. These parameters will have to be injected, so CDI will look for values for them. If it cannot find ways to build them, an error will be raised. The example we just wrote is very naive, and we will have trouble to make it work, because CDI will have trouble finding an `int` value to inject in this constructor. So in this particular case, using an annotated constructor is certainly not the best way to go! Do not worry, we are going to see others.

==== Using a producer

Providing a _producer_ to tell CDI how to create the missing instance is another possibility, and in our case, the right one.

What is a `Producer`? It is just an annotation put on something CDI will use to create an instance of a type. Here CDI needs to create an instance of the `PostRepository` type, so we need to annotate such a way.

The `@Producer` annotation can be put on several elements of a class.

* It can be put on a method. This method should return an instance of the right type. CDI will call this method to get that instance and use it.
* It can also be put on a field. This time, CDI will simply read that field to get that instance.

Let us see examples of those two cases.

==== Producer methods

So let us add the following class to our example.

[[app_listing]]
.The `PostRepositoryProducer` class
[source,java]
----
package chap04.producer;

import chap04.repository.InMemoryPostRepository;
import chap04.repository.PostRepository;

import javax.enterprise.inject.Produces;

public class PostRepositoryProducer {

    @Produces // <1>
    public PostRepository buildPostRepository() {
        return new InMemoryPostRepository(16);
    }
}
----
<1> Putting the `@Producer` annotation here informs CDI that it should call this method to build instances of `PostRepository`

If we run our example again, the error message is gone.

Note that a producer method (that is, a method annotated with `@Produces`) is one way among others for CDI to build a bean. If we add an explicit no-arg constructor to our `InMemoryPostRepository` class, then CDI will have two ways to build an instance of `PostRepository`, leading to an ambiguous dependency, and another error. We will see ways of dealing with this later in this chapter

A producer method can be nearly any kind of method. It can be static or non-static, private, protected, public or package protected. It should be _seen_ by CDI, so it should be a method of a managed bean, or a method of an EJB.

A producer method might return a null value. Of course in that case, odd things may happen. This is still possible, and handled by CDI. There are restrictions though, that we will see later in this book.

A producer method may have parameters. Since this method is called by CDI, those parameter have to be injected. So all the parameters of a producer method are treated as injection points when CDI calls this method.

==== Producer fields

The `@Produces` annotation can also be put on a field. This may looks odd, because a method call may look so much logical! There is in fact one case where it is extremely useful: the case where this field is itself injected. Let us look at the following example.

[[app_listing]]
.An injected producer field
[source,java]
----
@Stateless
public class PostEJB {

    @PersistenceContext(unitName="PostPersistenceUnit") @Produces
    private EntityManager entityManager;

    // rest of the class
}
----

The field `entityManager` if an EJB field, due to the `@Stateless` annotation. So the Java EE container will set the `entityManager` field prior to any method call on this EJB. It is in fact the recommended way of getting a JPA entity manager in a Java EE context.

The fact is: we can use this field to create a CDI producer, just by putting the `@Produces` annotation on this field.

This pattern is extremely useful to add any kind of Java EE resource (whether it is a datasource, a web service, a JMS queue) to a CDI application and use it directly.

This pattern can be used in any application: an injected field can become itself a producer for other types.

=== What is the type of a bean?

==== Bean types are Java types

So far we saw that CDI is able to associate producers and injection points based on the type of both. In a nutshell, an `EntityManager` producer will be used to create `EntityManager` beans, and to inject an `EntityManager` injection point.

Let us take a closer look at this notion of bean type, because it is a bit more tricky than it seems, especially in the Java EE world.

For instance, our `InMemoryPostRepository` has the following definition.

[[app_listing]]
.Types of the `InMemoryPostRepository` class
[source,java]
----
public class InMemoryPostRepository
implement PostRepository {

    // content of the class
}
----

From the Java type sytem point of view, this class has two explicitly defined types: `InMemoryPostRepository` and `PostRepository`. And CDI will follow this, so this bean can be injected in the two corresponding types of injection points.

But this class also extends the `Object` class, as it is the case for all the Java classes. And indeed, CDI recognizes that. So if you have an injection point of type `Object`, it can be injected with an instance of the `InMemoryPostRepository` class. Of course, you should not do that, because an injection point of type `Object` can be injected with so many types that you will probably in trouble.

So we can see that the types seen by CDI are in fact the plain Java types.

In fact, a bean type may be the following.

* Any interface, class or abstract class can be a CDI Bean Type.
* Any parameterized Java type, as long as the parameter has a defined value. For instance `List<String>` is a legal CDI Bean Type, whereas `List<E>` is not.
* Any raw type is a legal CDI Bean Type. For instance, `List` is the raw type of `List<E>` and is a legal CDI Bean Type.
* Any array of legal type is a legal CDI Bean Type.
* Any primitive type is also a legal CDI Bean Type.

All the other types are not legal CDI Bean Type, in particular, types parameterized with wildcards are not legal.

==== Bean Types of a bean produced by a producer method or field

The CDI Bean Type of a bean produced by a producer method or field is fixed by the returned type of this producer method, or the type of this field.

There are three cases to consider.

* If the defined type of the producer is an interface, then the CDI Bean Type is the set composed of this interface, all the super-interfaces if any, and the `Object` type, which is always there.
* If the defined type of the producer is a class, then the CDI Bean Type is the set of composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces if any, and their super-interfaces if any.
* And if the defined type of the producer is an array or a primitive type, then the CDI Bean Type is the set composed of this array or primitive type, and the `Object` type.


==== Bean types in the Java EE world

The Java EE world brings three notions that have an impact on the definition of CDI Bean Types.

===== The case of Resources

Resources are elements that may be defined outside of a Java EE application itself. There are usually defined at the Java EE application server level. Think of a JMS queue, a database connection, that can be exposed through a `DataSource` or a JPA `EntityManager`. In fact an `EntityManager` is bound to a transaction more than a database connection, but this is the object with which interact in a Java EE code.

Java EE allows for the injection of such resources in our code, through annotated fields or setters. Those objects are injected either through fields or method parameters.

The CDI Bean Type of such an injected resource in simply the CDI Bean Type of the injected field or parameter. Most of the time, the declaration of this field or parameter will be an interface. We already defined the CDI Bean Type of an interface, it is simply the set composed of this interface and all its super-interfaces, and the `Object` type.

===== The case of Managed Beans

The case of managed beans has also been seen. This managed bean has a defined class, so the CDI Bean Type of this managed bean is the set composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces and their super-interfaces.

===== The case of Session Beans

The case of the session beans is a bit more complex, since we need to understand how a session bean exposes its type to the Java EE container.

In Java EE 5 and before, a session bean was exposed through an interface, that could be declared local or remote. This is still the case bytheway, since it is possible to expose a session bean to remote calls. So in this case, CDI treats this bean as an interface instance, and the rules pertaining to interfaces hold. Thus, such a bean has a CDI Bean Type composed of this interface, all the super-interfaces, and the `Object` type.

When Java EE 6 was released, this constrain of having an interface for a session bean has been relaxed. Now a session can also be a simple annotated class, with no defined interface. Of course this kind of bean cannot be accessed remotely. In that case, CDI treats this bean as a class instance, and the rules pertaining to classes hold. Thus, such a bean has a CDI Bean Type composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces, and their super-interfaces.


=== Defining a first CDI bean: choose your bean type using Qualifiers

Probably the first question that comes to mind at this point is the following: what happens if I have more that one implementation for a given interface? CDI will probably be in trouble to choose from those implementations. It is quite easy to test that, so let us do it, and write another implementation for our repository. This time we will not repeat the mistake we did: it will be concurrent aware!

[[app_listing]]
.A second, concurrent aware, implementation of the `PostRepository` interface
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

public class InMemoryConcurrentPostRepository implements PostRepository {

    private AtomicLong id = new AtomicLong(0L);
    private ConcurrentMap<Long, Post> posts = new ConcurrentHashMap<>();

    @Override
    public void save(Post post) {
        long postId = id.getAndIncrement();
        posts.put(postId, post);
    }
}
----

What happens if we run the same code, without any other modification? Well, it does not work too well. In fact, an error is raised, which is the following.

[[app_listing]]
.Error raised for two implementations of the same interface
[source]
----
Exception in thread "main" org.jboss.weld.exceptions.DeploymentException: WELD-001409: Ambiguous dependencies for type PostRepository with qualifiers @Default
  at injection point [BackedAnnotatedField] @Inject private chap04.service.PostServiceImpl.postRepository
  at chap04.service.PostServiceImpl.postRepository(PostServiceImpl.java:0)
  Possible dependencies:
  - Managed Bean [class chap04.repository.InMemoryPostRepository] with qualifiers [@Any @Default],
  - Managed Bean [class chap04.repository.InMemoryConcurrentPostRepository] with qualifiers [@Any @Default]
----

There are details that we cannot understand yet in this error message, we will see all these later in this part. But in a nutshell, CDI complains because it sees two possible implementations for the `PostRepository` dependency, and has no rule on which one to choose from.

How can we explain to CDI which bean to choose from when more than one type (here `InMemoryPostRepository` and `InMemoryConcurrentPostRepository`) matches the type we need, namely `PostRepository`? This is what we are going to describe now.

In fact there is already a hint in the error message. If we read the error message carefully, it tells us that there is more than one bean of type `PostRepository` with qualifier `@Default`. Indeed, a _qualifier_ is a CDI notion that is there to bring more semantic to a Java type. CDI sees this semantic and can tell two beans that have the same Java type. Thus, CDI can choose which bean should be used, with this qualifier.

CDI defines a default qualifier: `@Default`. All the beans have this qualifier, thus the presence of this reference in the error message.

==== Using a qualifier on a simple example

A qualifier is a very simple Java element: it is just an annotation.

This annotation can be put along with the `@Produces` annotation. This is a very simple way to tell CDI that this field or method produces elements qualified by the annotation we put. Let us see a simple example.

We saw that we could inject persistence contexts in an EJB field. Suppose we have two databases: one for our posts, and another one for our users. We then have two different persistence contexts, since one persistence context can access to one database.

[[app_listing]]
.An EJB with two entity managers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    private EntityManager userEntityManager;

    // rest of the class
}
----

If we use those two fields as CDI producers, we will get an error, since the type of those fields is the same: `EntityManager`.

We need to add semantic, telling CDI exactly what are those fields: the first one deals with posts, and the second one with users. This is exactly what qualifiers are for.

[[app_listing]]
.An EJB with two entity managers, and qualified producers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    @Produces @DBPost
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    @Produces @DBUser
    private EntityManager userEntityManager;

    // rest of the class
}
----

On this second example, we put the `@Produces` annotation on each field, making them CDI produces. Along with the `@Produces` annotation, we add another annotation `@DBPost` and `@DBUser`. Those annotations are qualifiers, and CDI uses them to tell `postEntityManager` from `userEntityManager`. We will see in a moment how these annotations are built.

The rest is very easy to guess: we use the exact same way to qualify an injection point, so that CDI can tell which bean it should put in that field.

[[app_listing]]
.Injection with a qualifier
[source,java]
----
public class PostService {

    @Inject @DBPost
    private EntityManager entityManager;

    // rest of the class
}
----

On this last example, CDI knows that is should inject the entity manager qualified by `@DBPost`.

==== Writing a qualifier

This is all great, there is just one element missing: how does CDI know that those annotations we used, `@DBPost` and `@DBUser` are qualifiers? We know how to write annotations in Java, but what CDI magic makes an annotation a qualifier?

Well, there is indeed some kind of magic here, called meta-annotation. A qualifier is an annotation (no doubt about that!) itself annotated by a special CDI annotation: `@Qualifier`. This annotation has to be seen by CDI, so it has to be put in a bean archive. When CDI sees that this annotation is annotated by `@Qualifier`, it records it as such, so that we can use it in our code.

Let us create `@DBPost`, since we need to be able to use it.

[[app_listing]]
.Defining the `@DBPost` qualifier
[source,java]
----
import javax.inject.Qualifier;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Qualifier // <1>
@Retention(RetentionPolicy.RUNTIME) // <2>
@Target({ElementType.METHOD, // <3>
         ElementType.FIELD,
         ElementType.PARAMETER,
         ElementType.TYPE})
public @interface DBPost {
}
----
<1> This is the annotation CDI needs to tell that `DBPost` is a qualifier
<2> Of course a qualifier is analyzed by CDI when we launch our application, se we need it at runtime
<3> those are the Java elements we can put our `DBPost` annotation on. This list has to be compatible with `@Produces` and `@Inject`, since a qualifier has to be put with those two annotations.

A qualifier might look a little tricky to create. The use of this meta-annotation is not a very common pattern. The fact is: CDI relies a lot on annotations, and uses this pattern in many places. So this is the right time to get used to it. In fact it is quite easy to follow. Just create the annotation you need, add this special CDI annotation to it, `@Qualifier` in our example, and that is all you need to do.

===== Qualifiers with attributes

It is legal for a qualifier to define attributes. In that case, CDI will compare the two annotations along with the values of their attributes. Those values are compared with their respective `equals()` method, as we expected.

A qualifier may also define attributes that are not taken into account in the comparison. In this case, this attribute should be annotated with `@Nonbinding`.

In the case an annotation attribute type is an array, then it should be annotated with `@Nonbinding`. If not, then non predictable or implementation dependent results will occur.

Let us see that on an example. We could have created one annotation `@DB` with a default value to tell from the user database and the post database.

[[app_listing]]
.Defining the `DBType` enumeration
[source,java]
----
public enum DBType {

    POST, USER
}
----

[[app_listing]]
.Defining the `DB` qualifier, with a `DBype` attribute
[source,java]
----
import javax.enterprise.util.Nonbinding;
import javax.inject.Qualifier;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Qualifier // <1>
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,
         ElementType.FIELD,
         ElementType.PARAMETER,
         ElementType.TYPE})
public @interface DB {

    DBType value(); // <2>

    @Nonbinding String comment() default ""; // <3>
}
----
<1> The definition of this qualifier is the same as the previous one
<2> Here we declare the `value()` attribute
<3> And here the `comment()` attribute, which is made optional

So we can now use this qualifier on the produce side in this way.

[[app_listing]]
.Redefining the entity manager producers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    @Produces @DB(DBType.POST) // <1>
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    @Produces @DB(value=DBType.USER, comment="This is the User DB") // <2>
    private EntityManager userEntityManager;

    // rest of the class
}
----
<1> We do not need to tell that its attribute is the `value()` attribute, due to the way annotations work in Java
<2> Since we set a non-default value for the `comment()` attribute, we need to tell that `DBType.USER` is the value of the `value` attribute

==== Injecting by type, injecting by qualifier

CDI has in fact two ways of telling which bean should be injected where.

It can discriminate beans based on their Java type. But soon, you will discover that this is not enough. We saw it on the entity manager example. On one hand, we have the `EntityManager` type, and on the other hand we have different databases that cannot be discriminated solely on the type of the injected object.

So we need more information, and this information is brought by qualifiers. A qualifier can be seen as an element that is there to add the piece of information we need along with the type of a bean. It tells CDI that this injection point needs an `EntityManager` that points to our user database for instance.

==== Qualifiers of a bean

The notion of qualifier is of course linked to the notion of bean. We say, in the CDI context, that a bean has qualifiers. But this is quite an abstract notion, because we never really see this bean. What we see is where and how it is produced, and where and how it is used, or injected.

In fact, a bean has all the qualifiers defined on its producer method, plus a number of qualifiers CDI adds with certain default rules that we are going to see. This defines the qualifiers possessed by a bean.

And on the other hand, when we use a bean, that is, when a bean is injected in our code, this qualifier is bound to have a set of qualifiers defined on the injection point.

So this notion of qualifier can be seen from three points of view:

* the qualifiers that a bean has
* the qualifiers defined at the producer lever
* the qualifiers defined at the injection point

===== Adding a qualifier on a producer

We saw that a producer could be a method or a field, thus adding a qualifier on those two elements makes perfect sense.

===== Adding a qualifier on a type

We also saw that CDI sees the `InMemoryPostRepository` and `InMemoryConcurrentPostRepository` classes as two possible instances of the `PostRepository` interface, without any kind of information, metadata or configuration from us. It is its default behavior. To tell those two implementations, we can add a qualifier directly on the classes themselves. This pattern will be the following.

[[app_listing]]
.Qualifying types
[source,java]
----
@SimpleRepository
public class InMemoryPostRepository implements PostRepository {
    // content of the class
}

@ConcurrentRepository
public class InMemoryConcurrentPostRepository implements PostRepository {
    // content of the class
}
----

The two annotations `@SimpleRepository` and `@ConcurrentRepository` are two qualifiers that CDI uses to tell those two implementations. Using them on the injection points will tell CDI which one to use on which place.

===== Qualifiers on the injected constructor

We also saw the case of a CDI bean that has no empty constructor, due to the presence of one or more constructors with arguments. We saw that one of those constructors can be annotated with `@Inject`, allowing CDI to use this constructor to build this bean using this constructor. And at last, we saw that, in this case, all the parameters of this constructor are injected by CDI, since it is CDI itself that calls this constructor.

We do not need to annotate those parameters with `@Inject`, since this is the default CDI behavior. But we can put qualifiers on them. CDI will use those qualifiers to tell which bean it should inject. The pattern is the following.

[[app_listing]]
.Qualifying injected parameters
[source,java]
----
public class PostServiceImpl implements PostService {

    @Inject // <1>
    public PostServiceImpl(
        @ConcurrentRepository postRepository) { // <2>
        // content of the constructor
    }

    // rest of the class
}
----
<1> Tells CDI that it should use this constructor to create an instance of `PostService`
<2> Tells CDI to use the `InMemoryConcurrentPostRepository` bean to call this constructor

===== Adding a qualifier on an injection point

Any number of qualifiers can be added on a CDI injection point. CDI will look for a bean that matches all the defined qualifiers. If no bean, or more than one bean matches the definition, then an error will be raised. Of course, this bean can have more qualifier than needed to be injected. The set of all the qualifiers a bean has has to be a subset of the needed qualifiers.

==== Existing qualifiers

CDI defines four qualifiers:

* `@Named`
* `@New`
* `@Default`
* `@Any`


===== The `@Named` qualifier

This qualifier has a special status, as giving a name to a bean is mandatory for certain categories of beans in the Java EE world. But we can also give names to our beans outside of this context, just for the sake of the readability of our code.

This annotation defines a `value` attribute, which holds the name of the annotated bean.

===== The `@New` qualifier

This qualifier was defined in CDI 1.0, and deprecated in CDI 1.1. So you should not use it in your code, apart from using it for legacy reasons. We are not going to cover this annotation in details. Instead of injecting `@New` beans, you should inject `@Dependent` beans.

The `@New` annotation can take a default attribute which type is a class. This class is the one to instantiate to inject the annotated bean. If the value attribute is not specified, then the class of the bean will be instantiated.

===== The `@Default` qualifier

CDI adds the `@Default` qualifier on all the beans that have no qualifier. There is an exception for the `@Named` qualifier: a bean that has this qualifier will get the `@Default` qualifier also. So any producer that has no qualifier, or that has the `@Named` qualifier as its only qualifier, has this `@Default` qualifier.

Adding this qualifier explicitly is perfectly legal from a pure technical point of view, but would not make a lot of sense: let CDI handle this qualifier for you.

The same goes for the injection point. CDI adds the `@Default` qualifier on any injection point that defines no qualifier. The use of the `@Named` qualifier on injection points is not recommended. The `@Named` qualifier implies string-based bean identification, and this approach is not the recommended one any more.


===== The `@Any` qualifier

The `@Any` qualifier is present on all the beans CDI can handle, except for the `@New` beans that you should not use in your application. So one could think that this qualifier is useless, since it is present everywhere. It has in fact a very precise use, that we will see later, when we talk about programatic lookup.

The fact that this qualifier is present on all producers explains the error message we saw when we created ambiguous injection points and producers.

==== Injection by identifier vs injecting by type

So at this point, we have two ways of producing and injection beans. The first one relies on the Java type system. It works very well, leads to very simple and clean code, as well as robust patterns. But as we saw, most of the time it is not precise enough, since we may want to produce several beans of different kinds, but with the same type. We saw the example of the `EntityManager`, and there are many other. Many configuration parameters of our applications are injected in various places, and they are all `String`, `int`, or other very general Java types.

So CDI introduces the notion of _qualifier_ to add precision on the Java type of a bean. A qualifier is a just a simple annotation, that we can add both on the producing side, and on the injection side.

The full CDI Bean Type is thus the combination of the Java types (classes and interfaces) of a given bean, and its qualifiers.

In some cases, we might want to not take into account all the Java type hierarchy. For instance, we might want to add to the CDI Bean Type, only the interfaces, and not the implementing class, not the `Object` class. And even for the interfaces, some of them do not carry an relevant information for our CDI application. It might be the case for `Serializable` or `Cloneable`.

The question is: can we remove some Java types that a bean has from the CDI Bean Type? It turns out that the answer is yes. We can add an annotation on the production side that we tell CDI what Java types to take into account when building the CDI Bean Type. This annotation is simply `@Typed`, and it gives the list of those Java type. Let us go back to our `InMemoryConcurrentPostRepository` example, and let us add the `Serializable` interface to its declaration.

[[app_listing]]
.The CDI Bean Type of the `InMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

How does CDI build the CDI Bean Type of this bean?

First, this class does not have any qualifier, so CDI automatically adds the `@Any` and `@Default` qualifiers to it. If we had added an explicit qualifier, then the `@Default` qualifier would not have been there.

Then CDI adds the Java types: `InMemoryConcurrentPostRepository` of course, but also `Object`, as it is the case for all the beans. Then it also adds the two declared interfaces: `PostRepository` and `Serializable`.

Now the question is: do we really need the `Object` type and the `Serializable` Java types? They are so general, that they do not carry much information. Having general types in our CDI Bean Type set might lead to weird errors in our applications. Suppose we forget to add a dependant JAR for instance, with some important producers in it. The error we might get is that there are too many beans with the type `Object` to inject at a given injection point. What we would like to have is an error stating that this injection point has no matching bean to inject.

So we may add the `@Typed` annotation to the definition of our bean.

[[app_listing]]
.The CDI Bean Type of the `InMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

@Typed(PostRepository.class)
public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

This time, the only Java type we have in the CDI Bean Type is `PostRepository`, and this is what we expect.

So the `@Typed`annotation, is another annotation we have in our toolbox to select which Java type CDI gives to a bean, among the available Java types a bean has.


=== Advanced concepts in qualifying bean

There are two concepts we need to go through on the topic of the CDI Bean Type system. Those two concepts are `@Alternative` and `@Specializes`. These concepts are quite complex, but in some vey precise cases, needed in CDI applications.

==== Introduction

Suppose we have a working CDI application with many producers and injection points. Everything was very carefully designed and written, and the application heavily relies on qualifiers to associate producers and injection points.

And for some reason, testing, debugging, you name it, we need to substitute a bean with another bean. We want to provide a class that should be used by CDI to create a given bean, wherever this bean is used in our application. This can be a real nightmare to do, especially if our application is large an complex.

The solution cannot rely on adding some kind of information (qualifier for instance) on the injection points. First it would be very error prone (suppose we forget one). And it would also be very complex. This would not lead to a reliable solution, also due to the fact that an application can get an instance of a bean by programmatic lookup, a point that we have not seen yet.

So the only reliable way to do that is to act on the producing side. An approach one could think of could be to create a class with the exact same Java types. The simplest way to do that is to extend the class we want to substitute and the same qualifiers to it. But by doing that, we would create an ambiguity in our CDI application, since we would define two beans with the same CDI Bean Type. We cannot add a special qualifier to it, since we would then need to add this qualifier everywhere on the injection side, a solution that we discarded.

This is exactly for this kind of situation that the `@Alternative` concept has been created in CDI. The bean we want to substitute to the normal, injected bean, is declared as the _alternative_ of the normal bean, and then, CDI will magically inject this alternative in place of the normal bean.

==== Creating an `@Alternative` bean

From a technical point of view, creating an alternative bean is really simple. We just need to add the `@Alternative` annotation where the bean is produced and we are done.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class as an alternative using an annotation
[source,java]
----
package chap04.repository;

import javax.enterprise.inject.Alternative;

@Alternative
public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

===== Annotation versus XML declaration

Adding an annotation is very simple, but it requires the compilation of the class where we added the annotation. We must consider two cases here.

The first one is the case where this alternative class is a separate class, created for this case. Adding this annotation to this class is the natural way of doing it. If this class is a test class, it will not be deployed at runtime. If this class is some temporary class that we need to add to our application for debugging or auditing purposes, then we can put it in a separate JAR and remove that JAR when we do not need it anymore. In both cases, we do not need to recompile all our application to declare this alternative.

The second case is a bit more complex. We want a class that is already in our application to become the alternative. If we decide to add this annotation to it, then we will need to recompile everything, a step that might be costly, too costly for our needs.

We might come across this kind of situation quite often in Java EE applications. Another famous example is the declaration of named queries in JPA modules. You have two ways to do that: the first one is to add them using annotations, thus requiring to rebuild your application.

Instead of doing it that way, we can also add the declaration of alternatives in the `beans.xml` file. Using this way, we do not need to recompile our application, we only need to redeploy it with the modified `beans.xml`file. It is good to keep in mind this way of modifying the configuration of Java EE elements, since it may prove much more efficient than having to recompile and rebuild everything.

Declaring an alternative in the `beans.xml` configuration file is really easy. Let us see the following example.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class as an alternative in the `beans.xml`configuration file
[source,xml]
----
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                           http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd">

   <alternatives>
      <class>chap04.repository.InMemoryConcurrentPostRepository</class>
   </alternatives>
</beans>
----

===== More than one bean annotated with `@Alternative`

It is possible to have more than one bean with the same CDI Bean Types annotated with `@Alternative`. Of course this case will raise errors due to ambiguities in the resolution of which of those beans should be used to injection. In this case, one of these classes has to be referenced in the `beans.xml` file to resolve the ambiguity.

===== Selecting an alternative bean with the `@Priority` annotation

There is still another way to choose from several beans annotated with `@Alternative`. This way consists in adding a `@Priority` annotation along with the `@Alternative` annotation. This annotation will make this bean the chosen one among the other alternatives. The `@Priority` annotation takes an `int` attribute that has no default value. So we must give a value to this priority. The exact meaning of this attribute is left to the specifications that use them. CDI does indeed mention it for alternatives, but does not give precision on the way this attribute is used. So far we assume that only one alternative can be annotated with `@Priority`.


===== Alternative use cases

Alternatives are a very powerful tool that can be used in several use cases.

The first one of course is when we need to inject of mock object to test a special class. Declaring our mock class as an alternative makes it very easy to inject this mock object instead of the runtime bean. The mocked class is only known in the test context, and will not be deployed at runtime (if it is the case, fix it!). So all we need to do if to extend the class of the real bean, sparkle some mocking magic on it, put the same qualifiers on this class, and add declare it as an alternative, either by annotating it, or by declaring it in the `beans.xml` file.

But we can also imagine other use cases. Suppose our application is internationalized. We could imagine having a bunch of supported locales, each represented by sets of classes, put in different packages. These classes are in fact models for CDI beans, and are meant to be injected, or are referenced by JSF templates. One way of organizing this is to set the correct set of class as the alternative in a given deployment scenario using a given locale. 

==== Creating a `@Specializes` bean

Unfortunately, there are still cases where alternatives are not enough to override a given bean definition.

Remember that an alternative is selected as a bean only if both CDI Bean Type are the same. Let us consider the following example.

We are still dealing with our in-memory `PostRepository`. So we have this interface `PostRepository`, and two implementing classes, `InMemoryPostRepository` and `InMemoryConcurrentPostRepository`. We learned about qualifiers and decided to further explain the difference between those two implementations by putting a `@Concurrent` annotation on the `InMemoryConcurrentPostRepository` implementation.

So the declaration of these two classes is the following.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class with the `@Concurrent` qualifier
[source,java]
----
package chap04.repository;

@Concurrent
public class InMemoryConcurrentPostRepository implements PostRepository {

    // content of the class
}
----

[[app_listing]]
.Declaring the `InMemoryPostRepository` class
[source,java]
----
package chap04.repository;

public class InMemoryPostRepository implements PostRepository {

    // content of the class
}
----

Now, for testing purposes, we decide to extend the `InMemoryConcurrentPostRepository` class with a mocking class: `MockInMemoryConcurrentPostRepository`. The definition of this last class is the following.

[[app_listing]]
.Declaring the `MockInMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

public class MockInMemoryConcurrentPostRepository extends InMemoryConcurrentPostRepository {

    // content of the class
}
----

This is our setup for the definition of the beans we are going to use.

Of course, we have different injection points for these post repositories in our application. Let us see a first one, that just needs a `PostRepository`.

[[app_listing]]
.Declaring an injection point for a post repository
[source,java]
----
@Inject
private PostRepository repository;
----

What is going to happen with our setup? Well, CDI will first register the beans that can be injected in this field. It will find 3 of them: `InMemoryPostRepository`, `InMemoryConcurrentPostRepository` and `MockInMemoryConcurrentPostRepository`. And since it has no information to tell which implementation should be used, an error will be raised. We need to fix our code.

Thanks to our hard work in trying to learn CDI, we know that we have this `@Alternative` annotation that we can add on a type to resolve ambiguities. This is what we do: we add the `@Alternative` annotation on the declaration of `MockInMemoryConcurrentPostRepository`. And indeed it fixes the ambiguity, our testing code is running smoothly.

But then we realize that when this mocking class is not there anymore, the ambiguity is still there: CDI cannot tell from `InMemoryRepository` and `InMemoryConcurrentRepository`. Basically our test was running smoothly, but in production it did not work, due to the fact that this alternative is not there anymore.

We then to resolve this ambiguity again. We could use `@Alternative` agin, bu we prefer to add the `@Concurrent` annotation, since this is what our code needs. This approach is the best one, since is makes our code more readable. This time, our injection point looks like the following.

[[app_listing]]
.Declaring an injection point for a concurrent post repository
[source,java]
----
@Inject @Concurrent
private PostRepository repository;
----

Indeed, this annotation fixes our code in production, since the injected bean has to have the `@Concurrent` qualifier.

And then we realize that our test code does not work anymore! The `MockInMemoryConcurrentPostRepository` is not injected; the test code still injects the`InMemoryConcurrentPostRepository`. Why so? Simply because the qualifiers are not inherited. The `MockInMemoryConcurrentPostRepository` does not have the qualifier `@Concurrent` and thus is not a candidate for injection here. This will probably not look natural for many people. What are we doing here? We extend a class, add the `@Alternative` annotation on it thinking that it will fully override the class we extend, and in fact it does not, because the annotations are not inherited.

Most of the time this is not what we want. This is precisely to overcome this problem that the specialization has been added to CDI. In a nutshell, adding the `@Specializes` annotation to the overriding class will do the trick: CDI will take it in place of the overridden class, wherever this class is used.

When a bean _specializes_ another bean then we are sure that this other bean is not used as a bean by CDI. It is not seen, not instantiated, nothing.

For a bean to be a specialization of another bean, either its class must directly extends the class of this other bean, either its producing method must directly override the producing method of the first bean. Then the `@Specializes` annotation must be added to the class or to the producing method, as the case may be. Note that it the producer is in fact a field, no specialization can be set up, since a field cannot be overridden.

This specialization has a side effect, which is probably the desired effect in most cases. If the original bean declares itself one or several producing methods, or observers, those will not be seen by CDI, and thus not activated. Once again, this is probably what we want, since specialization will be used, most of the time, in a testing environment.

=== Getting more flexibility with Programmatic lookup

* @Any
* Instance<T>
* AnnotationLiteral, TypeLiteral

=== Using @Stereotype to simplify @Alternative
=== Wrap-up

