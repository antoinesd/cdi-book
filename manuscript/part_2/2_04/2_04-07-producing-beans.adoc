=== Producing home made beans

We saw in the previous parts what a CDI bean is and how CDI can inject a bean somewhere in our code. There is still one missing element: how can CDI create beans? In fact we gave a first answer to this question, in our first example. CDI was able to find an implementation of an interface, could instantiate this class an inject the resulting object where it was needed.

This was a very simple case: one interface, one implementing class, with its empty constructor. Life is sometimes more complicated than that, and CDI needs more information to create the objects it needs.

This part is about the notion of CDI _producer_. A producer can be several things, but in a nutshell, it is a mean for CDI to create beans.

Why should we need producers? The answer to this question is very simple: because the very simple case we showed as a first example is probably too simple. Real applications are more complex than that.

Let us show this on an example. Suppose that our `InMemoryPostRepository` needs a parameter to be built: namely the size of the underlying `HashMap` used to save our posts.

[[app_listing]]
.The `InMemoryPostRepository` class with no empty constructor
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

The main difference between this version of this class and the previous one is that CDI cannot build it on its own. Why? Because the empty constructor that was present in the previous version is not here anymore. So CDI cannot rely on the Java reflection API to build instances of this bean. And indeed, if we run our example again, we get this error message.

[[app_listing]]
.Error met with a bean with no empty constructor
[source,txt]
----
Exception in thread "main" org.jboss.weld.exceptions.DeploymentException: WELD-001408: Unsatisfied dependencies for type PostRepository with qualifiers @Default
  at injection point [BackedAnnotatedField] @Inject private chap04.service.PostServiceImpl.postRepository
  at chap04.service.PostServiceImpl.postRepository(PostServiceImpl.java:0)
----

Since CDI could not find a way to build an instance of the `PostRepository` type, it could not build the `PostService` neither. All our object graph is broken.

How can we solve that? Precisely by defining a producer fo the `PostRepository` type. There are three ways of defining such a producer.

* The first one is to add an `@Inject` annotation on the constructor of this class. In fact we already saw this possibility in the previous paragraph.
* The second one is to add a `@Produces` annotation on a method that returns an instance of `PostRepository`.
* The third one is to add a `@Produces` annotation on a field of the right type.

Let us examine those three possibilities. 

==== Annotated constructor

First, we can annotate the constructor CDI should use with the `@Inject` annotation.

[[app_listing]]
.Annotating the constructor of the `InMemoryPostRepository` class
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    @Inject
    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

If our class has several constructors, only one should be annotated. If more than one constructor is annotated, then CDI will raise an error.

CDI will then call this constructor to build an instance of `InMemoryPostRepository`, and will need values for the parameters of this constructor. These parameters will have to be injected, so CDI will look for values for them. If it cannot find ways to build them, an error will be raised. The example we just wrote is very naive, and we will have trouble to make it work, because CDI will have trouble finding an `int` value to inject in this constructor. So in this particular case, using an annotated constructor is certainly not the best way to go! Do not worry, we are going to see others.

==== Using a producer

Providing a _producer_ to tell CDI how to create the missing instance is another possibility, and in our case, the right one.

What is a `Producer`? It is just an annotation put on something CDI will use to create an instance of a type. Here CDI needs to create an instance of the `PostRepository` type, so we need to annotate such a way.

The `@Producer` annotation can be put on several elements of a class.

* It can be put on a method. This method should return an instance of the right type. CDI will call this method to get that instance and use it.
* It can also be put on a field. This time, CDI will simply read that field to get that instance.

Let us see examples of those two cases.

==== Producer methods

So let us add the following class to our example.

[[app_listing]]
.The `PostRepositoryProducer` class
[source,java]
----
package chap04.producer;

import chap04.repository.InMemoryPostRepository;
import chap04.repository.PostRepository;

import javax.enterprise.inject.Produces;

public class PostRepositoryProducer {

    @Produces // <1>
    public PostRepository buildPostRepository() {
        return new InMemoryPostRepository(16);
    }
}
----
<1> Putting the `@Producer` annotation here informs CDI that it should call this method to build instances of `PostRepository`

If we run our example again, the error message is gone.

Let us note two things about this producer method.

First, a producer method may have parameters. Since this method is called by CDI, and not by our code explicitly, CDI will have to provide values for those parameters. Those values will be injected by CDI. So all the parameters of a producer method are treated as injection points when CDI calls this method.

Second, a producer method might return a null value. Of course in that case, odd things may happen. This is still possible, and handled by CDI. There are restrictions though, that we will see later in this book.

A producer method can be nearly any kind of method. It can be static or non-static, private, protected, public or package protected. It should be _seen_ by CDI, so it should be a method of a managed bean, or a method of an EJB.

==== Producer fields

The `@Produces` annotation can also be put on a field. This may looks odd, because a method call may look so much logical! There is in fact one case where it is extremely useful: the case where this field holds a resource, and is itself injected. There are many examples of that in the Java EE world. Let us look at the following example.

[[app_listing]]
.An injected producer field
[source,java]
----
@Stateless
public class PostEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    @Produces
    private EntityManager entityManager;

    // rest of the class
}
----

The field `entityManager` if an EJB field, due to the `@Stateless` annotation on its class. So the Java EE container, because of the `@PersistenceContext` annotation will look for a `PostPersistenceUnit`  persistence unit, declared in a `persistence.xml` file. It will then create the corresponding `EntityManagerFactory` and then a `EntityManager`, to be injected in the `entityManager` field. This will take place prior to any method call on this EJB. It is in fact the recommended way of getting a JPA entity manager in a Java EE context.

Now that we have an we have a `EntityManager`, we still have two possibilities to build a producer.

The first one is to create a getter for this field, and annotate this getter with the `@Produce` annotation. This will work perfectly well, and is the _producer method_ pattern we saw in the previous paragraph.

The second one is to simply put the annotation `@Produces` on this field. It will do the trick: CDI can read the value it needs directly from the field, without having to go through a setter.

This pattern is extremely useful to add any kind of Java EE resource (whether it is a datasource, a web service, a JMS queue) to a CDI application and use it directly.

This pattern can be used in any application: an injected field can become itself a producer for other types.

==== Having more than one producer for a given type

With all these ways to define producers, it is very easy to have several producers for a given type. In certain cases, it might even be desirable. For instance, we can have a producer method (that is, a method annotated with `@Produces`) and an explicit no-arg constructor to our `InMemoryPostRepository` class. Maybe our application needs this no-arg constructor for some reason, and for another reason, we need to build our bean using this producer method.

The problem is, that CDI has two ways to build an instance of `PostRepository`, the empty constructor and the producer method. This leads to an ambiguous dependency, and CDI will raise an error. Fortunately, there are ways to resolve this ambiguity. We will see ways of dealing with this later in this chapter.
