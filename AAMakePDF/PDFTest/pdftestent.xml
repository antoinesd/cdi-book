<?xml version="1.0" encoding="UTF-8"?><book xmlns="http://www.manning.com/schemas/book" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ns="http://www.manning.com/schemas/book">
  <bookinfo id="_185_438_0">
  <title id="_185_438_1">Agile Author Sample</title>
  <author id="_185_438_2"><firstname id="_185_438_3">Nicholas</firstname><surname id="_185_438_4">Chase</surname></author> 
  </bookinfo>
  <toc id="_185_438_5">
  <tocfront id="_185_438_6">Preface</tocfront>
  <tocpart id="_185_438_7">
    <tocentry id="_185_438_8">Part 1:  The Groovy language</tocentry>
    <tocchap id="_185_438_9">
      <tocentry id="_185_438_10">1 Your way to Groovy</tocentry>
    </tocchap>
    <tocchap id="_185_438_11">
      <tocentry id="_185_438_12">2 <addToIndex>Overture</addToIndex>: The Groovy basics </tocentry>
    </tocchap>
    <tocchap id="_185_438_13">
      <tocentry id="_185_438_14">3 The simple Groovy datatypes </tocentry>
    </tocchap>
    <tocchap id="_185_438_15">
      <tocentry id="_185_438_16">4 The collective Groovy datatypes</tocentry>
    </tocchap>
    <tocchap id="_185_438_17">
      <tocentry id="_185_438_18">5 Working with closures </tocentry>
    </tocchap>
    <tocchap id="_185_438_19">
      <tocentry id="_185_438_20">6 Groovy control structures </tocentry>
    </tocchap>
    <tocchap id="_185_438_21">
      <tocentry id="_185_438_22">7 Dynamic object orientation, Groovy style </tocentry>
    </tocchap>
    <tocchap id="_185_438_23">
      <tocentry id="_185_438_24">8 Groovy Meta Programming</tocentry>
    </tocchap>
  </tocpart>
  <tocpart id="_185_438_25">
    <tocentry id="_185_438_26">Part II: Around the Groovy library</tocentry>
    <tocchap id="_185_438_27">
      <tocentry id="_185_438_28">9 Working with builders </tocentry>
    </tocchap>
    <tocchap id="_185_438_29">
      <tocentry id="_185_438_30">10 Working with the GDK </tocentry>
    </tocchap>
    <tocchap id="_185_438_31">
      <tocentry id="_185_438_32">11 Database programming with Groovy </tocentry>
    </tocchap>
    <tocchap id="_185_438_33">
      <tocentry id="_185_438_34">12 Integrating Groovy </tocentry>
    </tocchap>
    <tocchap id="_185_438_35">
      <tocentry id="_185_438_36">13 Working with XML </tocentry>
    </tocchap>
    <tocchap id="_185_438_37">
      <tocentry id="_185_438_38">14 Unit testing with Groovy </tocentry>
    </tocchap>
  </tocpart>
  <tocpart id="_185_438_39">
    <tocentry id="_185_438_40">Part III: Everyday Groovy  </tocentry>
    <tocchap id="_185_438_41">
      <tocentry id="_185_438_42">15 Tips and tricks </tocentry>
    </tocchap>
    <tocchap id="_185_438_43">
      <tocentry id="_185_438_44">16 Groovy modules and frameworks</tocentry>
    </tocchap>
    <tocchap id="_185_438_45">
      <tocentry id="_185_438_46">17 Concurrent programming with Groovy </tocentry>
    </tocchap>
    <tocchap id="_185_438_47">
      <tocentry id="_185_438_48">18 Creating Domain Specific Languages </tocentry>
    </tocchap>
    <tocchap id="_185_438_49">
      <tocentry id="_185_438_50">19 Groovy best practice patterns </tocentry>
    </tocchap>
  </tocpart>
  <tocback id="_185_438_51">Appendix A: Installation and documentation </tocback>
  <tocback id="_185_438_52">Appendix B: Groovy language info </tocback>
  <tocback id="_185_438_53">Appendix C: GDK API quick reference </tocback>
  <tocback id="_185_438_54">Appendix D: Cheat sheets</tocback>
  </toc>
  
  <preface id="config_ch" label="2">
    <title id="_7_0_512">Configuring Mule (Live)</title>
  
    <abstract id="_185_438_55">
    <para id="_185_438_56">In this preface</para>
<itemizedlist id="_185_438_57"><listitem id="_185_438_58"><para id="_185_438_59">Communicating with the MuleClient</para></listitem>
<listitem id="_185_438_60"><para id="_185_438_61">Using context objects to interact with Mule</para></listitem>
<listitem id="_185_438_62"><para id="_185_438_63">AOP with component interceptors</para></listitem>
<listitem id="_185_438_64"><para id="_185_438_65">Leveraging the notification framework</para></listitem></itemizedlist>
    </abstract>
   
    <para id="_536_4496_0"><internalnote id="_185_438_66">YOU MUST NOT SEE THIS!!!</internalnote>In this chäpter, you'll learn the fundamentål principles of a Mule configuration file.  Said differently, this chapter
    will give you (?&#x2295;) the grammar of the configuration file, while the upcoming
    chapters will help you build your vocabulary. When you're done reading it,
    you'll be able to create new configuration files and set up the scene for
    your own services, which you'll learn to create in the coming
    chapters.</para><para id="_7_0_514">In essence, configuring Mule consists of defining the
    services you want to be active in a particular instance of the ESB. <emphasis role="bold">This should be in bold.</emphasis> <emphasis role="underline">This should be in underlined.</emphasis> <emphasis role="italic">This should be in italics.</emphasis> <emphasis>This should be in italics too..</emphasis> As
    seen in the previous chapter, these services are composed of and rely on
    many different moving parts, which also need to be configured. Some of
    these moving parts are<biblioref id="_185_438_67" linkend="bib1"/> intrinsically shared across several services, such
    as connectors.<biblioref id="_185_438_68" linkend="bib2"/> Others can be locally defined<biblioref endterm="myBibRef" id="_185_438_69"/> or globally configured and
    shared, such as endpoints. As you can guess, supporting this flexibility
    and richness in a configuration mechanism is pretty hairy.</para><para id="_7_0_515">To achieve this, Mule uses <emphasis id="_185_438_70">configuration
    builders</emphasis> <indexterm id="_185_438_71"><primary id="_185_438_72">configuration</primary><secondary id="_185_438_73">builder</secondary></indexterm>that can translate a human-authored configuration file into
    the complex graph of objects that constitutes a running node of this ESB.
    The main builders are of two kinds: a Spring-driven builder, which works
    with XML files, and a script builder, which can accept scripting language
    files.</para>
    
    <informalexample><programlisting>This is an example of a line of code text that is <lineArrow />
broken, but really should be one line.</programlisting></informalexample>
    
    <note id="_7_0_516"><title id="_185_438_74">The scripting configuration builder</title>
      <para id="_7_0_517">The scripting configuration builder  <indexterm id="_185_438_75"><primary id="_185_438_76">configuration</primary><secondary id="_185_438_77">scripted</secondary></indexterm> <indexterm id="_185_438_78"><primary id="_185_438_79">scripting</primary></indexterm>uses a script in any language for which a
      JSR-223 compliant <indexterm id="_185_438_80"><primary id="_185_438_81">JSR-223</primary><see id="_185_438_82">scripting</see></indexterm> engine exists (such as Groovy, JRuby, or Rhino). By
      default, Mule supports Groovy <indexterm id="_185_438_83"><primary id="_185_438_84">Groovy</primary></indexterm>configuration files, but other scripting languages can be
      added by installing the Mule Scripting Pack that can be downloaded from
      <code id="_185_438_85">http://mulesource.org/display/MULE/Download</code>. A scripted       configuration is a low-level approach to configuring Mule. It's up to       you to instantiate, configure, and wire all the necessary moving parts.       This requires an expert knowledge of Mule internals. This explains why       this approach is much less popular than XML configuration, as it's rare
      that anyone needs this level of control. This said, there can be
      circumstances where using Spring or XML isn't an option. In that
      situation, using a scripted configuration can save the day.</para></note>

    <para id="_7_0_518">In this chapter we'll mainly focus on configuring the
    Spring XML <indexterm id="_185_438_86"><primary id="_185_438_87">configuration</primary><secondary id="_185_438_88">Spring XML</secondary><tertiary id="_185_438_89">advantages</tertiary>
      </indexterm>builder, for several reasons:<orderedlist id="_7_0_519">
        <listitem id="_7_0_520">
          <para id="_7_0_521"><emphasis id="_185_438_90">It's the most
          popular</emphasis> you're more likely to find examples using this
          syntax.</para></listitem><listitem id="_7_0_522">
          <para id="_7_0_523"><emphasis id="_185_438_91">It's the most user
          friendly</emphasis> Spring takes care of wiring together all the
          moving parts of the ESB, something you must do by hand with a
          scripted builder.</para></listitem><listitem id="_7_0_524">
          <para id="_7_0_525"><emphasis id="_185_438_92">It's the most
          expressive</emphasis> dedicated XML schemas define the
          domain-specific language of Mule, allowing you to handle
          higher-level concepts than the scripting approach does.</para></listitem></orderedlist></para><para id="_7_0_526">We'll start by running a simple example, which will
    allow you to look at your first service configuration. We'll then review
    the overall structure, element families, and configurable items of the
    Spring XML file in general terms, just enough for you to get the gist of
    it and have the basic knowledge you'll need to grasp what you'll learn in
    the upcoming chapters. We'll also give some advice on how to organize your
    configuration files efficiently.</para><para id="_7_0_530">Are you ready for the ride? We believe the answer is
    yes, so let's start to look into our first Mule configuration file.</para><sect1 id="ch02_firstride_sec">
      <title id="_7_0_532">First ride</title><para id="_7_0_533">Though Mule comes complete with a 'hello' example,
      we chose to get started with the 'echo' example that's also bundled with
      the platform. We believe the echo example is the true 'hello world'
      example for Mule, as it doesn't require any transformer, custom
      component, or specific router. That's why we decided to nickname it
      'Echo World <indexterm id="_185_438_93"><primary id="_185_438_94">echo world</primary></indexterm>.'</para><para id="_7_0_535">Let's now look into details of the Echo World
      example <indexterm id="_185_438_95"><primary id="_185_438_96">Mule</primary><secondary id="_185_438_97">basic example</secondary></indexterm>. As shown in figure <xref id="_7_0_536" linkend="ch02_echo-sample_fig"/>, this application uses the
      <code id="_185_438_98">stdio</code> transport <indexterm id="_185_438_99"><primary id="_185_438_100">stdio</primary><secondary id="_185_438_101">transport</secondary></indexterm>to receive messages from the console input       (<code id="_185_438_102">stdin</code>) <indexterm id="_185_438_103"><primary id="_185_438_104">console</primary><secondary id="_185_438_105">reading from</secondary><tertiary id="_185_438_106">stdin</tertiary>
        </indexterm>and send these messages unchanged directly to the console
      output (<code id="_185_438_107">stdout</code>) <indexterm id="_185_438_108"><primary id="_185_438_109">console</primary><secondary id="_185_438_110">writing to</secondary><tertiary id="_185_438_111">stdout</tertiary>         </indexterm>. A specific component, called a
      <emphasis id="_185_438_112">bridge</emphasis> <indexterm id="_185_438_113"><primary id="_185_438_114">component</primary><secondary id="_185_438_115">bridge</secondary></indexterm>, is used to pass the messages from the inbound router to
      the outbound one. A bridge is a neutral component: it doesn't perform
      any action or modify the messages that it processes. The outbound router
      is a pass-through one <indexterm id="_185_438_116"><primary id="_185_438_117">pass-through-router</primary></indexterm>: it's the simplest router that exists. It dispatches the
      messages it receives to a unique endpoint.<figure id="ch02_echo-sample_fig">
          <title id="_7_0_537">Moving parts and message flow of the echo
          example</title><mediaobject id="_7_0_538">
            <imageobject id="_7_0_539">
              <imagedata fileref="figures/svgtest.svg" id="_7_0_540" width="600"/>
            </imageobject>
          </mediaobject>
        </figure></para><para id="_7_0_541">Listing <xref id="_7_0_542" linkend="ch02_echo-sample_lis"/> provides the full configuration for
      this example. As an astute reader, you'll quickly notice that there's no
      bridge component. This is because a service uses a bridge component
      implicitly <indexterm id="_185_438_118"><primary id="_185_438_119">bridge component</primary><secondary id="_185_438_120">implicit</secondary></indexterm>if none is configured. Except for this subtlety, the
      configuration file is pretty straightforward. Note how the specific
      attributes on the different elements help to make the configuration
      self-explanatory.</para>
        <example id="ch02_echo-sample_lis" >
          <title id="_7_0_543">The echo example XML <addToIndex>configuration</addToIndex><!--cueballs in code and text--></title><programlisting id="_7_0_544" xml:space="preserve"><codelink commentStyle="XML" file="codelistings/codenolinkend.txt"/></programlisting><calloutlist id="_7_0_545">

            <callout arearefs="ch06_echo-sample-con_cod ch06_echo-sample-con_cod2 ch06_echo-sample-con_coda" id="ch06_echo-sample-con_cor"><para id="_7_0_546">Defines and configures 
standard input connector</para></callout>

            <callout arearefs="ch06_echo-sample-ser_cod ch06_echo-sample-ser_coda" id="ch06_echo-sample-ser_cor"><para id="_7_0_547">The echo service</para></callout>
          </calloutlist>
        </example>
      <para id="_7_0_548">In example <co id="ch06_echo-sample-con_coda"/>, we installed the Mule standalone server and at <co id="ch06_echo-sample-ser_coda"/>
      downloaded the examples from this book's companion web site. So, at this
      point, you should be able to start this example. For this, go into the
      <filename id="_185_438_121">/chapter02/echo</filename> directory and run the
      <filename id="_185_438_122">echo-xml</filename> batch file that suits your OS. The output
      should be as shown here, with a version and a build number that match
      your Mule installation and with the host name of your machine <indexterm id="_185_438_123"><primary id="_185_438_124">standalone server</primary><secondary id="_185_438_125">startup sequence</secondary></indexterm>:</para><informalexample id="_185_438_126"><programlisting id="_7_0_554" xml:space="preserve"><codelink file="codelistings/codewithlinkend.txt" linkend="ne-setup"/></programlisting></informalexample><para id="_7_0_555">As prompted, enter something. Note that the first
      time a message gets dispatched to the outbound endpoint, Mule
      instantiates and connects the necessary dispatcher:</para><informalexample id="_185_438_127"><programlisting id="_7_0_558" xml:space="preserve"><codelink file="codelistings/None.java" linkend="maybe-none"/></programlisting></informalexample><para id="_7_0_559">When you're tired of playing with the echo, stop the
      execution <indexterm id="_185_438_128"><primary id="_185_438_129">standalone server</primary><secondary id="_185_438_130">stopping</secondary></indexterm>of the application with <code id="_7_0_560">control+C</code>. All the log entries you'll see scrolling       on your console will represent a normal and clean shutdown of the       ESB <indexterm id="_185_438_131"><primary id="_185_438_132">standalone server</primary><secondary id="_185_438_133">shutdown sequence</secondary></indexterm>. The very last lines shown in the console should be like
      this:</para><informalexample id="_185_438_134"><programlisting id="_7_0_563" xml:space="preserve">*********************************************************************
* The server is shutting down due to normal shutdown request        *
* Server started: 28/02/09 15:52                                    *
* Server shutdown: 28/02/09 15:53                                   *
*********************************************************************
&lt;-- Wrapper Stopped</programlisting></informalexample><para id="_7_0_564">Note how <code id="_7_0_565">control+C</code> has       been interpreted as a normal shutdown request. If the JVM were to exit       abruptly, for example because of a hard crash, the wrapper       script <indexterm id="_185_438_135"><primary id="_185_438_136">standalone server</primary><secondary id="_185_438_137">wrapper script</secondary></indexterm>would restart the instance automatically.</para><para id="_7_0_566">Even if basic, this example has shown you what less
      than 20 lines of configuration can buy you in Mule. You also got the
      gist of the runtime environment of Mule, how it behaves at startup and
      shutdown times, and what it reports in the logs.</para><para id="_7_0_589">The Echo World example has given you some clues
      about the organization of the Spring XML configuration file.<footnote id="_185_438_138"><para id="_185_438_139">The same example is also provided as a scripted configuration
          in <filename id="_185_438_140">echo-world/conf/echo-config.groovy</filename> if you're
          curious to discover this configuration approach as well.</para></footnote> Let's now broaden your view by exploring the structure of
      this configuration file.</para></sect1><sect1 id="_7_0_590">
      <title id="_7_0_591">The Spring XML configuration</title><para id="_7_0_592">The Spring configuration builder <indexterm id="_185_438_141"><primary id="_185_438_142">Spring</primary><secondary id="_185_438_143">XML configuration builder</secondary></indexterm> <indexterm id="_185_438_144"><primary id="_185_438_145">configuration</primary><secondary id="_185_438_146">Spring XML</secondary></indexterm> <indexterm id="_185_438_147"><primary id="_185_438_148">XML configuration</primary><see id="_185_438_149">configuration</see></indexterm>relies on XML to enforce the correct syntax
      (well-formedness) and on XML Schema <indexterm id="_185_438_150"><primary id="_185_438_151">XML Schema</primary><see id="_185_438_152">configuration</see></indexterm>to define the grammatical rules (validity). These rules
      define the usable elements<footnote id="_7_0_593">
          <para id="_7_0_594"><emphasis id="_185_438_153">Element</emphasis> as defined by the
          W3C DOM specification.</para></footnote> and where they can be used. These elements represent the
      different moving parts of the ESB and their configurable
      parameters.</para><para id="_7_0_595">Mule doesn't rely on a single monolithic schema to
      define all the configurable elements, but instead on several of
      them <indexterm id="_185_438_154"><primary id="_185_438_155">configuration</primary><secondary id="_185_438_156">XML schema</secondary></indexterm>. One of these schemas defines the core elements and the
      general structure of the configuration file. Other elements are defined
      by optional additional schemas, such as the transport-specific ones. If
      you look at the first lines of listing <xref id="_7_0_596" linkend="ch02_echo-sample_lis"/>, you'll see that the core and the VM
      transport specific schemas are imported.</para><tip id="_185_438_157"><title id="_185_438_158">Best practice</title><para id="_185_438_159">Always validate your XML configuration files before attempting
        to load them in Mule to simplify troubleshooting.</para></tip>

      <para id="_7_0_597">Figure <xref id="_7_0_598" linkend="ch02_gen-conf_fig"/> represents the elements defined by the
      core schema <indexterm id="_185_438_160"><primary id="_185_438_161">configuration</primary><secondary id="_185_438_162">XML schema</secondary><tertiary id="_185_438_163">core</tertiary>
        </indexterm>. Note how the services, which are the main actors of a
      configuration, are lost in the bottom-right corner of the mind map. This
      gives you an idea of all the supporting common features and global
      elements you can declare in a configuration file. Throughout the book,
      you'll progressively learn more about each of these elements.</para><para id="_185_438_164">
        <figure id="ch02_gen-conf_fig">
          <title id="_7_0_602">Configuration structure defined by Mule's XML
          core schema</title><mediaobject id="_7_0_603">
            <imageobject id="_7_0_604">
              <imagedata fileref="figures/Ch1MissingData.svg" id="_7_0_605"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para><para id="_7_0_606">The Echo World configuration in listing <xref id="_7_0_607" linkend="ch02_echo-sample_lis"/> only has a few schema
      references and one global element (a connector). You can easily imagine
      that real-world configuration files declare many of these shared
      configuration artifacts to support the configuration of their services.
      In the examples coming in the next chapters, you'll often see such
      shared elements, like global endpoints or transformers. Some chapters
      will even be dedicated to some of these common elements, such as
      transaction managers or JMX agents.</para><para id="_7_0_608">For now, we'll consider these elements under several
      of their main characteristics. First we'll look at their main families,
      then how we can define configured values, and finally where to find the
      schemas that define them.</para><sect2 id="ch02_ele-fam_sec">
        <title id="_7_0_609">XML element families</title><para id="_7_0_610">Independent of their functions, we can
        conceptually distinguish three main families of elements <indexterm id="_185_438_165"><primary id="_185_438_166">configuration</primary><secondary id="_185_438_167">families of elements</secondary></indexterm>in a Mule configuration: <itemizedlist id="_7_0_611">
            <listitem id="_7_0_612">
              <para id="_7_0_613">The specific elements</para></listitem><listitem id="_7_0_614">
              <para id="_7_0_615">The custom elements</para></listitem><listitem id="_7_0_616">
              <para id="_7_0_617">The Spring elements</para></listitem></itemizedlist></para><para id="_7_0_618">It's important to understand what you can expect
        from each of these to build a configuration file in the most efficient
        manner.</para><formalpara id="_7_0_619">
          <title id="_7_0_620">Specific elements</title><para id="_7_0_621">The specific elements <indexterm id="_185_438_168"><primary id="_185_438_169">configuration</primary><secondary id="_185_438_170">specific elements</secondary></indexterm>are the most expressive configuration elements
          available, insofar as they constitute the domain-specific language
          of Mule <indexterm id="_185_438_171"><primary id="_185_438_172">Mule</primary><secondary id="_185_438_173">domain specific language</secondary></indexterm> <indexterm id="_185_438_174"><primary id="_185_438_175">domain specific language</primary></indexterm>. As such, these elements and their attributes are
          characterized by highly specific names. Another characteristic is
          that they intrinsically refer to predefined concrete
          implementations: they're used to express all the configuration
          elements that aren't custom-made. This is why no class name comes
          into play when using this kind of configuration element. A benefit
          of this is the isolation your configuration gets from the internals
          of Mule's implementation: if a class is renamed, your configuration
          won't be affected.</para></formalpara>

        <para id="_7_0_623">The Mule core and each transport or module you
        include in your configuration will contribute such specific elements.
        Table <xref id="_7_0_624" linkend="ch02_spec-el_tab"/> is a
        nonexhaustive list<footnote id="_7_0_625">
            <para id="_7_0_626">There are more XML elements defined in these
            schemas; only the most notable ones are listed here.</para></footnote> of these elements as defined by a few Mule XML
        schemas.</para><table id="ch02_spec-el_tab" renderWidth="650" renderHeight="1885">
          <title id="_7_0_627">Specific elements defined by some Mule
          schemas</title><tgroup cols="3" id="_7_0_628">
            <thead id="_7_0_629">
              <row id="_7_0_630">
                <entry id="_7_0_631"><para id="_185_438_176">Schema</para></entry>

                <entry id="_7_0_632">
                  <para id="_7_0_633"><addToIndex>Elements</addToIndex> defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_635"><para id="_185_438_177">Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_636">
              <row id="_7_0_637">
                <entry id="_7_0_638"><para id="_185_438_178">Mule Core</para></entry>

                <entry id="_7_0_639">
                  <para id="_185_438_179">
                  <variablelist id="_185_438_180">
                     <varlistentry id="_185_438_181">
                         <term id="_185_438_182">Models</term>
                         <listitem id="_185_438_183"><para id="_185_438_184">This would be the definition of models.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_185">
                     	<term id="_185_438_186">Transformers</term>
                     	<listitem id="_185_438_187"><para id="_185_438_188">This would be the definition of Transformers.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_189">
                     	<term id="_185_438_190">Routers</term>
                     	<listitem id="_185_438_191"><para id="_185_438_192">This would be the definition of Routers.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_193">
                     	<term id="_185_438_194">Filters</term>
                     	<listitem id="_185_438_195"><para id="_185_438_196">This would be the definition of Filters.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_197">
                     	<term id="_185_438_198">Components</term>
                     	<listitem id="_185_438_199"><para id="_185_438_200">This would be the definition of Components.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_201">
                     	<term id="_185_438_202">Security manager</term>
                     	<listitem id="_185_438_203"><para id="_185_438_204">This would be the definition of Security manager.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_205">
                     	<term id="_185_438_206">Exception strategies</term>
                     	<listitem id="_185_438_207"><para id="_185_438_208">This would be the definition of Exception strategies.</para></listitem>
                     </varlistentry>
                     <varlistentry id="_185_438_209">
                     	<term id="_185_438_210">Transaction manager</term>
                     	<listitem id="_185_438_211"><para id="_185_438_212">This would be the definition of Transaction manager.</para></listitem>
                     </varlistentry>
                  </variablelist>
                  </para>
                  
                  
                  </entry>

                <entry id="_7_0_651"><para id="_185_438_213">
                  <informalexample id="_7_0_653"><programlisting id="_7_0_654" xml:space="preserve">&lt;object-to-string-transformer
                  name="ObjectToString"/&gt;<lineArrow />
                  next line of clode</programlisting></informalexample></para>
                  <para id="_7_0_655">Defines a global object-to-string
                  transformer named <code id="_185_438_214">ObjectToString</code>. <indexterm id="_185_438_215"><primary id="_185_438_216">object-to-string-transformer</primary></indexterm></para><para id="_185_438_217"><informalexample id="_185_438_218"><programlisting id="_185_438_219" xml:space="preserve"><![CDATA[<global-property name="smtp.username"
  value="jqdoe" />]]></programlisting></informalexample></para>
                  <para id="_185_438_220">Defines a global property named
                  <code id="_185_438_221">smtp.username</code>, whose value is                   <code id="_185_438_222">jqdoe</code>. <indexterm id="_185_438_223"><primary id="_185_438_224">global-property</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_656">
                <entry id="_7_0_657"><para id="_185_438_225">HTTP Transport</para></entry>

                <entry id="_7_0_658">
                  <para id="_7_0_659">HTTP connector</para><para id="_7_0_660">HTTP endpoint</para><para id="_7_0_661">REST service component</para><para id="_7_0_662">HTTP request and response
                  transformers</para></entry>

                <entry id="_7_0_663">
                  <para id="_185_438_226"><informalexample id="_7_0_665"><programlisting id="_7_0_666" xml:space="preserve">&lt;http:polling-connector name="pollingHttp"
              pollingFrequency="3000"/&gt;</programlisting></informalexample></para>
                  <para id="_7_0_667">Defines an HTTP connector named
                  <code id="_185_438_227">pollingHttp</code>, which will be used for polling a                   URL every three seconds. <indexterm id="_185_438_228"><primary id="_185_438_229">polling-connector</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_668">
                <entry id="_7_0_669"><para id="_185_438_230">XML Module</para></entry>

                <entry id="_7_0_670">
                  <para id="_7_0_671">XML transformers</para><para id="_7_0_672">XML routers</para><para id="_7_0_673">XML filters</para></entry>

                <entry id="_7_0_674">
                  <para id="_185_438_231"><informalexample id="_7_0_676"><programlisting id="_7_0_677" xml:space="preserve">&lt;xm:xslt-transformer name="DocBook2FO"
         xsl-file="db2fo.xsl"/&gt;</programlisting></informalexample></para>
                 <para id="_7_0_678">Defines an XSL-T transformer named
                  <code id="_185_438_232">DocBook2FO</code>, which uses the templates defined in                   <code id="_185_438_233">db2fo.xsl</code>. <indexterm id="_185_438_234"><primary id="_185_438_235">xslt-transformer</primary></indexterm></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <formalpara id="_7_0_679">
          <title id="_7_0_680">Custom elements</title><para id="_7_0_681">Custom elements <indexterm id="_185_438_236"><primary id="_185_438_237">configuration</primary><secondary id="_185_438_238">custom elements</secondary></indexterm>constitute the Mule-oriented extension points of a
          configuration. They mainly allow you to use custom implementations
          or Mule classes for which no specific element has been created.
          These extension points are available for core Mule artifacts and
          also for some transports and modules. Custom elements usually rely
          on a fully qualified class name parameter to locate your custom
          code. They also provide a means to pass the property values your
          class needs to be properly configured. Table <xref id="_7_0_682" linkend="ch02_cust-el_tab"/> shows a few examples of these custom
          elements.</para></formalpara>

        <table id="ch02_cust-el_tab">
          <title id="_7_0_683">Custom elements defined by some Mule
          schemas</title><tgroup cols="3" id="_7_0_684">
            <thead id="_7_0_685">
              <row id="_7_0_686">
                <entry id="_7_0_687"><para id="_185_438_239">Schema</para></entry>

                <entry id="_7_0_688">
                  <para id="_7_0_689">Elements defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_691"><para id="_185_438_240">Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_692">
              <row id="_7_0_693">
                <entry id="_7_0_694"><para id="_185_438_241">Mule Core</para></entry>

                <entry id="_7_0_695">
                  <para id="_7_0_696">Custom transformer</para><para id="_7_0_697">Custom router</para><para id="_7_0_698">Custom filter</para><para id="_7_0_699">Custom entry point resolver</para><para id="_7_0_700">Custom security and encryption
                  providers</para><para id="_7_0_701">Custom exception strategy</para><para id="_7_0_703">Custom transaction manager</para></entry>

                <entry id="_7_0_704">
                  <para id="_185_438_242"><informalexample id="_7_0_706"><programlisting id="_7_0_707" xml:space="preserve">&lt;custom-transformer name="NameStringToChatString"
   class=
"org.mule.example.hello.NameStringToChatString"/&gt;</programlisting></informalexample></para>
                  <para id="_7_0_708">Defines a custom transformer named
                  <code id="_185_438_243">NameStringToChatString</code> as an instance of the specified class. <indexterm id="_185_438_244"><primary id="_185_438_245">custom-transformer</primary></indexterm></para></entry>
              </row>

              <row id="_7_0_709">
                <entry id="_7_0_710"><para id="_185_438_246">TCP Transport</para></entry>

                <entry id="_7_0_711"><para id="_185_438_247">Custom protocol</para></entry>

                <entry id="_7_0_712">
                  <para id="_185_438_248"><informalexample id="_7_0_714"><programlisting id="_7_0_715" xml:space="preserve">&lt;tcp:custom-protocol
class="org.mule.CustomSerializationProtocol"/&gt;</programlisting></informalexample></para>
                  <para id="_7_0_716">Defines a custom TCP protocol as an
                  instance of the specified class. <indexterm id="_185_438_249"><primary id="_185_438_250">custom-protocol</primary></indexterm></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para id="_7_0_725">Though it's possible to do what a specific XML
        element can do using a custom XML element, this should be avoided for
        two main reasons. The first is because you'll become coupled to a
        particular implementation in Mule itself: if a new class is created
        and used by the specific element, your custom one will keep
        referencing the old one. The second is because you'll lose the benefit
        of the strongly typed (schema validated) and highly expressive
        attributes defined on the specific elements.</para><tip id="_185_438_251"><title id="_185_438_252">Best practice</title><para id="_185_438_253">If possible, try to use a specific configuration element
          instead of custom one.</para></tip>

        <sect3 id="_7_0_726">
          <title id="_7_0_727">Spring elements</title><para id="_7_0_728">Thanks to the support of a few core Spring
          schemas<indexterm id="_185_438_254"><primary id="_185_438_255">configuration</primary><secondary id="_185_438_256">Spring elements</secondary></indexterm>, Mule can accept Spring elements <indexterm id="_185_438_257"><primary id="_185_438_258">Spring</primary><secondary id="_185_438_259">elements in configuration</secondary></indexterm>in its configuration. Spring elements are used to
          instantiate and configure any object that'll be used elsewhere in
          the configuration, where they'll usually be injected in standard
          Mule elements. They're also used to easily construct configuration
          parameters such as lists or maps. Finally, they allow configuration
          modularity through the support of the import element (see section
          <xref id="_7_0_729" linkend="ch02_conf-mod_sec"/>). Table <xref id="_7_0_730" linkend="ch02_spring-el_tab"/> shows a few examples
          of these Spring elements. Note how the
          <code id="_185_438_260">spring:beans</code> <indexterm id="_185_438_261"><primary id="_185_438_262">Spring</primary><secondary id="_185_438_263">beans</secondary></indexterm>element opens the door to the usage of any Spring           schema (in this example we use the <code id="_185_438_264">util</code> one).</para>
          <table id="ch02_spring-el_tab">           <title id="_7_0_731">Elements defined by the supported Spring
          schemas</title><tgroup cols="3" id="_7_0_732">
            <thead id="_7_0_733">
              <row id="_7_0_734">
                <entry id="_7_0_735"><para id="_185_438_265">Schema</para></entry>

                <entry id="_7_0_736">
                  <para id="_7_0_737">Elements defined (nonexhaustive list)</para></entry>

                <entry id="_7_0_739"><para id="_185_438_266">Example</para></entry>
              </row>
            </thead>

            <tbody id="_7_0_740">
              <row id="_7_0_741">
                <entry id="_7_0_742"><para id="_185_438_267">Spring Beans</para></entry>

                <entry id="_7_0_743">
                  <para id="_7_0_744">Beans</para><para id="_7_0_745">Bean</para><para id="_7_0_746">Property</para></entry>

                <entry id="_7_0_747">
                  <para id="_185_438_268"><informalexample id="_7_0_749"><programlisting id="_7_0_750" xml:space="preserve">&lt;spring:bean name="cfAMQ"
  class=
  "org.apache.spring.ActiveMQConnectionFactory"&gt;
  &lt;spring:property name="brokerURL"
    value="tcp://localhost:61616"/&gt;
&lt;/spring:bean&gt;</programlisting></informalexample></para>
                  <para id="_7_0_751">Instantiates an ActiveMQ connection
                  factory, configured with the specified broker URL parameter
                  and named <code id="_185_438_269">cfAMQ</code>. <indexterm id="_185_438_270"><primary id="_185_438_271">Spring</primary><secondary id="_185_438_272">property</secondary></indexterm></para><para id="_7_0_752">
                    </para><para id="_185_438_273"><informalexample id="_7_0_753"><programlisting id="_7_0_754" xml:space="preserve">&lt;spring:beans&gt;
  &lt;spring:import
     resource="classpath:applicationContext.xml" /&gt;
&lt;/spring:beans&gt;</programlisting></informalexample></para>
                 <para id="_7_0_755">Imports a Spring application context
                  from the classpath. <indexterm id="_185_438_274"><primary id="_185_438_275">Spring</primary><secondary id="_185_438_276">import</secondary></indexterm></para><para id="_185_438_277">
                    </para><para id="_185_438_278"><informalexample id="_185_438_279"><programlisting id="_185_438_280" xml:space="preserve">&lt;inbound-endpoint ref="globalEndpoint"&gt;
  &lt;properties&gt;
    &lt;spring:entry key="valueList"&gt;
      &lt;util:list&gt;
        &lt;spring:value&gt;value1 and others&lt;/spring:value&gt;
        &lt;spring:value&gt;value2&lt;/spring:value&gt;
      &lt;/util:list&gt;
    &lt;/spring:entry&gt;
  &lt;/properties&gt;
&lt;/inbound-endpoint&gt;</programlisting></informalexample></para>
                  <para id="_185_438_281">Sets a list property on an endpoint. <indexterm id="_185_438_282"><primary id="_185_438_283">Spring</primary><secondary id="_185_438_284">util schema</secondary></indexterm></para></entry>
              </row>

              <row id="_7_0_756">
                <entry id="_7_0_757"><para id="_185_438_285">Spring Context</para></entry>

                <entry id="_7_0_758"><para id="_185_438_286">Property placeholder resolver</para></entry>

                <entry id="_7_0_759">
                  <para id="_185_438_287"><informalexample id="_7_0_761"><programlisting id="_7_0_762" xml:space="preserve">&lt;context:property-placeholder 
   location="node.properties"/&gt;</programlisting></informalexample></para>
                  <para id="_7_0_763">Activates the replacement of placeholders, resolved against the specified properties file.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
	<para id="_185_438_288">When you start writing your own
          configuration files, you'll quickly realize how valuable this is.
          Whenever you configure a Mule object, the question of its default
          configuration values will arise. What would usually take a visit to
          the JavaDoc page of the object will now require only a glance at the
          default values for the different attributes supported by the XML
          element that represent the object (provided you use a decent tool).</para>
          
          <sect4><title>Sample Sect4</title>
          
          
          <para>This is a sample sect4.</para>
          
          <example><title>A sample sect4 listing</title><programlisting>public static void main(String[] args){
          System.out.println("Hello World.");
}</programlisting></example>
          
          
          </sect4>
          
          
          
</sect3>

<sect3 id="_185_438_289"><title id="_185_438_290">A sect3 should come last</title>

        <para id="_7_0_765">Besides configuration extension, Spring elements
        also grant access to the framework itself, making possible the usage
        of advanced features such as AOP. Though you can do a lot in Mule
        without deferring to Spring, getting acquainted with this framework
        will allow you to better grasp the core on which Mule is built. If
        you're unfamiliar with Spring or would like to learn more about it, we
        strongly recommend reading <emphasis id="_185_438_291">Spring in
        Action</emphasis> <indexterm id="_185_438_292"><primary id="_185_438_293">Spring in Action</primary></indexterm>from Manning Publications Co. (Walls and
        Breidenbach).</para><para id="_7_0_766">You've now learned to recognize the different
        families of XML elements you'll have to deal with and what you can
        expect from them. XML elements without values specific to your
        configuration are useless. Let's now see how you'll set these
        different values in your own configuration files.</para>
        </sect3>
        
        </sect2><sect2 id="ch02_config-values_sec">
        <title id="_7_0_767">Configured values</title><para id="_7_0_768">In a Mule configuration, values are seldom stored
        as text nodes; they're mainly stored as attributes of XML elements.
        The main exceptions are text-rich properties such as documentation or
        script elements. This makes the configuration easier to read, format,
        and parse, as attributes are less prone to being disrupted by unwanted
        whitespaces. These attributes are strongly typed, with data
        types <indexterm id="_185_438_294"><primary id="_185_438_295">configuration</primary><secondary id="_185_438_296">data types</secondary></indexterm>defined by the XML Schema standard.</para><para id="_7_0_769">We'll consider these configured values under their
        most notable traits:</para><itemizedlist id="_7_0_770">
          <listitem id="_7_0_771">
            <para id="_7_0_772">Default values</para></listitem><listitem id="_7_0_773">
            <para id="_7_0_774">Enumerated values</para></listitem><listitem id="_185_438_297"><para id="_185_438_298">Expressions</para></listitem><listitem id="_7_0_775">
            <para id="_7_0_776">Property placeholders</para></listitem><listitem id="_7_0_777">
            <para id="_7_0_778">Names and references</para></listitem></itemizedlist>

        <sect3 id="_7_0_779">
          <title id="_7_0_780">Default values</title><para id="_7_0_781">Using attributes to hold values enables the
          definition of default values<indexterm id="_185_438_299"><primary id="_185_438_300">configuration</primary><secondary id="_185_438_301">default values</secondary></indexterm>. Mule schemas take great care to define default
          values wherever possible. When you start writing your own
          configuration files, you'll quickly realize how valuable this is.
          Whenever you configure a Mule object, the question of its default
          configuration values will arise. What would usually take a visit to
          the JavaDoc page of the object will now require only a glance at the
          default values for the different attributes supported by the XML
          element that represent the object (provided you use a decent tool;
          see chapter <xref id="_7_0_782" linkend="dev.ch"/>).</para></sect3>

        <sect3 id="_7_0_783">
          <title id="_7_0_784">Enumerated values</title><para id="_7_0_785">On top of being strongly typed, some attributes
          define an enumeration of possible configuration values <indexterm id="_185_438_302"><primary id="_185_438_303">configuration</primary><secondary id="_185_438_304">enumerated values</secondary></indexterm>. This greatly reduces the risk of introducing a bogus
          value that would only be caught later on at runtime. This also
          provides valuable information about the intent of the parameter and
          the abilities of the configured object.</para></sect3>

        <sect3 id="_185_438_305"><title id="_185_438_306">Expressions</title><para id="_185_438_307">Mule's expression evaluation framework offers the capacity to
          define configuration values that are evaluated dynamically at
          runtime. With simple attribute values of the form
          <code id="_185_438_308">#[evaluator:expression]</code>, it is possible to access           almost any data from the current message being processed or the Mule           instance itself. Please refer to appendix <xref id="_185_438_309" linkend="expreval.anx"/> for more information about this powerful           framework.</para></sect3>

        <sect3 id="_7_0_786">
          <title id="_7_0_787">Property placeholders</title><para id="_7_0_788">An important aspect of any configuration file is
          the capacity to externalize certain values that can change at
          runtime. These values are called
          <emphasis id="_185_438_310">properties</emphasis> <indexterm id="_185_438_311"><primary id="_185_438_312">configuration</primary><secondary id="_185_438_313">properties</secondary></indexterm> <indexterm id="_185_438_314"><primary id="_185_438_315">property placeholders</primary></indexterm>. They're generally used to define
          environment-specific parameters such as credentials, port numbers,
          or paths. It's possible to use such properties in lieu of fixed
          values in any attribute of a Mule configuration. The property is
          then referred to by its name using a special placeholder syntax.
          This is done using the classic Ant notation <indexterm id="_185_438_316"><primary id="_185_438_317">Ant notation</primary></indexterm>, as shown: </para>
          <para id="_185_438_318"><informalfigure id="_7_0_789">
              <mediaobject id="_7_0_790">
                <imageobject id="_7_0_791">
                  <imagedata depth="151" fileref="figures/referencesHH.png" id="_7_0_792" width="609"/>
                </imageobject>
              </mediaobject>
            </informalfigure></para><para id="_185_438_319">These properties are defined either as global
          ones in the Mule configuration <indexterm id="_185_438_320"><primary id="_185_438_321">properties</primary><secondary id="_185_438_322">global</secondary><seealso id="_185_438_323">global-property</seealso></indexterm>, in a standard Java properties file <indexterm id="_185_438_324"><primary id="_185_438_325">properties</primary><secondary id="_185_438_326">file</secondary></indexterm>or in JVM system properties <indexterm id="_185_438_327"><primary id="_185_438_328">properties</primary><secondary id="_185_438_329">system</secondary></indexterm>. For the last two options, Spring's property
          placeholder resolver <indexterm id="_185_438_330"><primary id="_185_438_331">Spring</primary><secondary id="_185_438_332">property placeholder resolver</secondary></indexterm>(shown in table <xref id="_7_0_793" linkend="ch02_spring-el_tab"/>) takes care of injecting the
          properties value in your configuration.</para>

        <tip id="_12_0_3664">
          <title id="_12_0_3665">Environment properties</title><para id="_12_0_3666">As with any other application, you'll have to
          externalize environment-specific values in properties files. These
          are usually passwords, remote service URLs, port numbers, time-outs,
          or cron expressions. With Spring XML configurations, a good practice
          is leveraging Spring's <code id="_12_0_3667">PropertyPlaceholderConfigurer <indexterm id="_185_438_333"><primary id="_185_438_334">PropertyPlaceholderConfigurer</primary></indexterm></code> to load properties from several files on the           classpath. The idea is to define reasonable defaults for the
          development environment in a properties file embedded in the
          deployable itself, and to override <indexterm id="_185_438_335"><primary id="_185_438_336">properties</primary><secondary id="_185_438_337">override</secondary></indexterm>these values with others defined in an
          environment-specific property file placed also on the classpath, but
          outside of the deployable. This is demonstrated here:<!--Typesetting: note code continuation arrow [CA] below--></para><para id="_185_438_338"><informalexample id="_12_0_3668"><programlisting id="_12_0_3669">&lt;context:property-placeholder
              location="classpath:META-INF/default.props, [CA] \
              classpath:override.props" /&gt;</programlisting></informalexample></para><para id="_12_0_3670">This configuration element imports values from
          classpath files <filename id="_12_0_3671">META-INF/default.props</filename> and from <filename id="_12_0_3672">override.props</filename>. The latter can be left
          empty in development and tuned to use correct values in test or
          production environments. This construct also supports overriding
          with Java system properties: if a system property is defined, it'll
          take precedence over a property of the same name defined in one of
          these files.</para></tip>
</sect3>
        <sect3 id="_7_0_805">
          <title id="_7_0_806">Names and references</title><para id="_7_0_807">Being able to have elements that reference other
          elements is an essential aspect of a Mule configuration file. This
          is achieved by using name and reference attributes <indexterm id="_185_438_339"><primary id="_185_438_340">configuration</primary><secondary id="_185_438_341">names and references</secondary></indexterm>. Most of the elements can receive a name through this
          mechanism. References can sometimes be multivalued. In that case,
          whitespace is used to separate the different names that are referred
          to. The following demonstrates an inbound endpoint that refers to a
          chain of four transformers simply by listing their
          names:</para><para id="_185_438_342"><informalfigure id="_7_0_808">
              <mediaobject id="_7_0_809">
                <imageobject id="_7_0_810">
                  <imagedata fileref="figures/propertyPlaceholderHH.png" id="_7_0_811"/>
                </imageobject>
              </mediaobject>
            </informalfigure></para><para id="_185_438_343">You now know the secrets to setting values in
          your XML configurations. We'll now look at one thing that may still
          puzzle you: the location of all these different schemas.</para></sect3>
      </sect2><sect2 id="_7_0_812">
        <title id="_7_0_813">Schema locations</title><para id="_7_0_814">You might be wondering where to get an up-to-date
        list of all the available schemas you can use in your configurations.
        This section will do better than give you this list: it'll allow you
        to figure out by yourself the right schema reference to use for any
        Mule library you decide to use.</para><para id="_7_0_815">When you look at the declaration in listing <xref id="_7_0_816" linkend="ch02_echo-sample_lis"/>, you might be
        wondering if Mule will connect to the Internet to download the
        different schemas from the specified locations. Of course it doesn't.
        Each library (transport or module) embeds the schemas it
        needs <indexterm id="_185_438_344"><primary id="_185_438_345">configuration</primary><secondary id="_185_438_346">XML schema</secondary><tertiary id="_185_438_347">transport</tertiary>
          </indexterm>. Mule leverages the resource resolver mechanism of
        Spring <indexterm id="_185_438_348"><primary id="_185_438_349">Spring</primary><secondary id="_185_438_350">resource resolver</secondary></indexterm>to 'redirect' the public HTTP URIs into ones that are
        internal to the JAR file <indexterm id="_185_438_351"><primary id="_185_438_352">configuration</primary><secondary id="_185_438_353">XML schema</secondary><tertiary id="_185_438_354">in JAR files</tertiary>
          </indexterm>. How is this mechanism configured? To discover it, fire
        up your favorite archiving utility or IDE and open the library you
        want to use. There should be a directory named
        <filename id="_185_438_355">META-INF</filename>. After opening it, you should see
        something similar to the screen shot shown in figure <xref id="_7_0_817" linkend="ch02_schema-loc_fig"/>.<figure id="ch02_schema-loc_fig">
            <title id="_7_0_818">Locating the XML schema of the VM
            transport</title><mediaobject id="_7_0_819">
              <imageobject id="_7_0_820">
                <imagedata fileref="figures/independentConfigurations.gif" id="_7_0_821"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_822">The schema you're looking for is in the <filename id="_7_0_823">META-INF</filename> directory and is named after the
        transport or module name, prefixed with <code id="_185_438_356">mule-</code>. Figure         <xref id="_7_0_824" linkend="ch02_schema-loc_fig"/> shows that in the         VM transport, the schema is named <filename id="_7_0_825">mule-vm.xsd</filename>. Some transports have several         schemas, one per variation of the main transport (such as HTTP and
        HTTPS). The target namespace of the schema you're looking for is
        declared on the root element. Listing <xref id="_7_0_826" linkend="ch02_vm-trans-root_lis"/> shows the root element of the VM
        transport schema.</para><example id="ch02_vm-trans-root_lis" annotations="below">
            <title id="_7_0_827">The target namespace to use in configuration
            files is defined in the schema of each Mule library.</title><programlisting id="_7_0_828" xml:space="preserve"><codelink file="codelistings/codeJava.txt"/></programlisting><calloutlist id="_185_438_357">
            <callout arearefs="testjavacomment" id="_185_438_358">This is a test callout, and it should be below the text.  Also, it shouldn't come off to the right, but should be displayed properly..</callout>
            </calloutlist></example>
            
            <example id="ch02_vm-trans-root_lis2">
            <title id="_7_0_8272">This example tests the EL embedded</title><programlisting id="_7_0_8282" xml:space="preserve"><codelink file="codelistings/codeEl.txt"/></programlisting></example>
            
            
            
            <para id="_7_0_829">By now you should be anxious to know where the
        schema location <indexterm id="_185_438_359"><primary id="_185_438_360">configuration</primary><secondary id="_185_438_361">XML schema</secondary><tertiary id="_185_438_362">location</tertiary>
          </indexterm>is defined. Using the right location is important in
        order for the 'redirection' mechanism to kick in and allow Mule to
        validate and load your configuration file. This mechanism is
        configured by the file named <filename id="_7_0_830">spring.schemas</filename>, which is located alongside
        the library schema. You can see this file in figure <xref id="_7_0_831" linkend="ch02_schema-loc_fig"/>. The content of this
        file is a simple mapping between the remote schema location and the
        archive file to use for it, as shown:<informalfigure id="_7_0_832">
            <mediaobject id="_7_0_833">
              <imageobject id="_7_0_834">
                <imagedata fileref="figures/schemaLocationHH.gif" id="_7_0_835"/>
              </imageobject>
            </mediaobject>
          </informalfigure></para><para id="_7_0_836">The schema location you want to use is on the left
        of the equal sign. Bear in mind that because properties files require
        you to escape colons, the backslash in front of the equal sign should
        be omitted if you copy and paste the location directly into your
        configuration file. With the target namespace and the schema location
        in hand, you should now be able to add the VM transport schema to your
        configuration file. Listing <xref id="_7_0_837" linkend="ch02_vm-conf-root_lis"/> shows you what you should have come
        up with.</para><example id="ch02_vm-conf-root_lis">
            <title id="_7_0_838">The root element of a Mule configuration that
            uses the VM transport<!--cueballs in code and text--></title><programlisting id="_7_0_839" xml:space="preserve"><codelink commentStyle="XML" file="codelistings/codeXML.txt" linkend="servlet_DispatcherServlet"/></programlisting><calloutlist id="_7_0_840">
              <callout arearefs="ch06_root-vm_cod" id="ch06_root-vm_cor">
                <para id="_7_0_841">Defines VM transport namespace</para></callout>

              <callout arearefs="ch06_root-vm-loc_cod" id="ch06_root-vm-loc_cor">
                <para id="_7_0_842">Location of VM transport schema</para></callout>
            </calloutlist>
          </example><para id="_7_0_843">Throughout this chapter, we've referred to the
        Mule core schema. If you look for it in
        <filename id="_185_438_363">mule-core.jar</filename> <indexterm id="_185_438_364"><primary id="_185_438_365">mule-core.jar file</primary></indexterm>, you'll be disappointed. It's in fact located in
        <filename id="_185_438_366">mule-module-spring-config.jar</filename> <indexterm id="_185_438_367"><primary id="_185_438_368">mule-module-spring-config.jar file</primary></indexterm>. Why there and not in the core JAR? Because using
        Spring XML is one possibility for building a Mule configuration. As we
        said in the introduction, there are other ways, such as
        scripting.</para><tip id="_7_0_844">
          <title id="_7_0_845">My valid configuration doesn't load!</title><para id="_7_0_846">It's possible to create a configuration that
          refers to all the right schemas and is well formed and valid, but
          still doesn't load. If this happens to you and you get a cryptic
          message like the following <indexterm id="_185_438_369"><primary id="_185_438_370">configuration</primary><secondary id="_185_438_371">XML schema</secondary><tertiary id="_185_438_372">namespace handler</tertiary>
            </indexterm> <indexterm id="_185_438_373"><primary id="_185_438_374">NamespaceHandler</primary></indexterm>:</para><para id="_185_438_375"><informalexample id="_7_0_847"><programlisting id="_7_0_848" xml:space="preserve">Configuration problem: Unable to locate
NamespaceHandler for namespace
[http://www.mulesource.org/schema/mule/xyz/2.2]</programlisting></informalexample></para><para id="_185_438_376">Then get ready for a 'duh' moment. This means
          you've forgotten to add to your classpath the Mule library that
          defines the namespace handler required to load configuration
          elements in said namespace. Watch out for missing transport or
          module JARs.</para></tip>

        <para id="_7_0_849">By now, you're certainly eager to rush to your
        keyboard and start building your own configurations. Before that, we'd
        like to introduce the notion of modular configurations. This will help
        you tame the complexity that may arise in your configurations when
        your projects start expanding.</para><sidebar id="_185_438_377"><title id="_185_438_378">Another hint</title><para id="_185_438_379">Consider also reading chapter, where
          we discuss the development tools you'll need, before starting a Mule
          project.</para></sidebar>
      </sect2></sect1><sect1 id="ch02_conf-mod_sec">
      <title id="_7_0_850">Configuration modularity</title><para id="_7_0_851">Have you ever had to wade through pages and pages of
      configuration, trying to sort things out and find your way around? As
      your integration projects grow and multiply, there's a risk that your
      configuration files may become bloated or redundant, hence hard to read,
      test, and maintain. Fortunately, the configuration mechanism of Mule
      allows you to relieve the ails of a monolithic configuration by
      modularizing it <indexterm id="_185_438_380"><primary id="_185_438_381">configuration</primary><secondary id="_185_438_382">modularity</secondary></indexterm>.</para><note id="_185_438_383"><title id="_185_438_384">Best practice</title><para id="_185_438_385">Modularize your configuration files to make them easier to read
        and simplify their maintenance.</para></note>

      <para id="_7_0_852">Cutting a configuration into several parts
      encourages the following <indexterm id="_185_438_386"><primary id="_185_438_387">configuration</primary><secondary id="_185_438_388">modularity</secondary><tertiary id="_185_438_389">advantages</tertiary>
        </indexterm>:<itemizedlist id="_7_0_853">
          <listitem id="_7_0_854">
            <para id="_7_0_855">Reuse <indexterm id="_185_438_390"><primary id="_185_438_391">configuration</primary><secondary id="_185_438_392">reuse</secondary></indexterm>of common artifacts across several
            configurations</para></listitem><listitem id="_7_0_856">
            <para id="_7_0_857">Extraction of environment-dependent <indexterm id="_185_438_393"><primary id="_185_438_394">configuration</primary><secondary id="_185_438_395">environment dependent</secondary></indexterm>configuration artifacts</para></listitem><listitem id="_7_0_858">
            <para id="_7_0_859">Isolation of functional aspects that become
            testable in isolation <indexterm id="_185_438_396"><primary id="_185_438_397">configuration</primary><secondary id="_185_438_398">testability</secondary></indexterm></para></listitem></itemizedlist></para><para id="_7_0_860">There are different approaches that can be used when
      modularizing a configuration. In the following sections, we'll detail
      these strategies: <itemizedlist id="_7_0_861">
          <listitem id="_7_0_862">
            <para id="_7_0_863">Independent configurations</para></listitem><listitem id="_7_0_864">
            <para id="_7_0_865">Inherited configurations</para></listitem><listitem id="_7_0_866">
            <para id="_7_0_867">Imported configurations</para></listitem><listitem id="_7_0_868">
            <para id="_7_0_869">Heterogeneous configurations</para></listitem></itemizedlist></para><para id="_7_0_870">Of course, you can combine them together. At the end
      of the day, the objective of this discussion is to give you a hint of
      the possibilities and let you establish the configuration organization
      that best fits your project size and needs.</para><warning id="_185_438_399"><title id="_185_438_400">Using an existing context</title><para id="_185_438_401">In section 7.1, we'll discuss another
        handy option: using an existing Spring context as the parent context
        of your Mule configuration. Because this isn't done at configuration
        level, we won't detail this approach here.</para></warning><sect2 id="_7_0_871">
        <title id="_7_0_872">Independent configurations</title><para id="_7_0_873">As shown in figure <xref id="_7_0_874" linkend="ch02_indep-conf_fig"/>, a Mule instance can load several
        independent configuration files side by side <indexterm id="_185_438_402"><primary id="_185_438_403">configuration</primary><secondary id="_185_438_404">modularity</secondary><tertiary id="_185_438_405">independent files</tertiary>
          </indexterm>. In this example, Mule will use two Spring XML
        configuration builders to instantiate, configure, and wire together
        the elements defined in both XML configuration files. As you can see,
        the environment-dependent properties have been exported in an external
        file, loaded from the instance-specific configuration file.<figure id="ch02_indep-conf_fig">
            <title id="_7_0_875">A Mule instance can load independent XML
            configuration files and properties files.  We also want to test out a multi-line figure caption.</title><mediaobject id="_7_0_876">
              <imageobject id="_7_0_877">
                <imagedata fileref="figures/inheritedConfigurations.gif" id="_7_0_878" width="442"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_879">This approach is well suited for simple scenarios,
        where there's a loose coupling between the common and
        instance-specific elements. It allows a fair level of reuse, as global
        elements such as connectors, transformers, or endpoints can be shared
        with several instance-specific configurations.</para><para id="_7_0_880">The main drawback of using independent
        configurations is that the instance-specific configuration doesn't
        strongly express its need to run alongside the common configuration.
        If the shared elements aren't used immediately, like transformers, you
        can start the Mule instance without the required common configuration
        and start having issues only later on at runtime.</para><para id="_7_0_881">Using inherited configurations alleviates this
        problem.</para></sect2><sect2 id="_7_0_882">
        <title id="_7_0_883">Inherited configurations</title><para id="_7_0_884">The concept of inherited configurations is
        illustrated in figure <xref id="_7_0_885" linkend="ch02_inher-conf_fig"/>. The main idea is to express a formal
        parent-child dependency between two configurations <indexterm id="_185_438_406"><primary id="_185_438_407">configuration</primary><secondary id="_185_438_408">modularity</secondary><tertiary id="_185_438_409">inheritance</tertiary>
          </indexterm>. By strongly expressing this dependency, you'll have
        the guarantee at boot time that no configuration file has been omitted
        (unlike the behavior you get with side-by-side independent
        configurations as described in the previous section).<figure id="ch02_inher-conf_fig">
            <title id="_7_0_886">Models can be inherited, leading to enforced
            hierarchies of configuration files.</title><mediaobject id="_7_0_887">
              <imageobject id="_7_0_888">
                <imagedata fileref="figures/inheritedHeterogeneousConfigurations.gif" id="_7_0_889"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_890">Inheritance can only be defined between models:
        this is why the parent and child models are represented. Because a
        model can be empty, this inheritance approach is suitable even if the
        common configuration doesn't have any model elements to share. It's
        also good to know that several different models can inherit from the
        same parent. The modularization can therefore span several
        configuration files.</para><para id="_7_0_891">How is this inheritance expressed? Simply by using
        the same name for the parent and child models and by flagging the
        child as being an heir <indexterm id="_185_438_410"><primary id="_185_438_411">model</primary><secondary id="_185_438_412">inheritance</secondary></indexterm>, as shown here:</para><informalexample id="_7_0_892"><programlisting id="_7_0_893" xml:space="preserve">&lt;model name="myConfig"&gt;
&lt;model name="myConfig" inherit="true"&gt;</programlisting></informalexample><para id="_7_0_894">In this configuration sample, the parent model
        doesn't have an <code id="_185_438_413">inherit</code> attribute, which defaults to         false when absent, and the child model has the attribute set to         <code id="_185_438_414">true</code>.</para></sect2><sect2 id="_7_0_895">
        <title id="_7_0_896">Imported configurations</title><para id="_7_0_897">As briefly discussed in section <xref id="_7_0_898" linkend="ch02_ele-fam_sec"/>, Spring can be leveraged
        to instantiate and configure any infrastructure or custom bean you
        need for your Mule instance. For example, Spring can perform JNDI
        lookups or wire your business logic beans together. After time, your
        Spring configuration may grow to the point that it starts to clutter
        your Mule configuration. Or you might decide that part of your Spring
        configuration is reusable. At this point, extracting your Spring beans
        to a dedicated application context file would be the right thing to
        do. Figure <xref id="_7_0_899" linkend="ch02_impor-conf_fig"/> shows
        a situation where such shared application contexts have been created
        and are used by a hierarchy of Mule configurations.<figure id="ch02_impor-conf_fig">
            <title id="_7_0_900">Imported Spring application context files can
            complement a hierarchy of Mule configurations.</title><mediaobject id="_7_0_901">
              <imageobject id="_7_0_902">
                <imagedata fileref="figures/inheritedSpringConfigurations.gif" id="_7_0_903"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_904">You can easily import external Spring application
        context files from your Mule configuration files. <indexterm id="_185_438_415"><primary id="_185_438_416">configuration</primary><secondary id="_185_438_417">modularity</secondary><tertiary id="_185_438_418">importing files</tertiary>
          </indexterm><footnote id="_185_438_419"><para id="_185_438_420">Interactions between Mule and Spring configurations are
            further discussed in <xref id="_185_438_421" linkend="ch07.embedded.sec"/>.</para></footnote> The following illustrates how <code id="_7_0_905">instance-conf.xml</code>, shown in figure <xref id="_7_0_906" linkend="ch02_impor-conf_fig"/>, would import its         Spring <indexterm id="_185_438_422"><primary id="_185_438_423">Spring</primary><secondary id="_185_438_424">import</secondary></indexterm>context file:</para><informalexample id="_7_0_907"><programlisting id="_7_0_908" xml:space="preserve">&lt;spring:beans&gt;
    &lt;spring:import resource="instance-beans.xml" /&gt;
&lt;/spring:beans&gt;</programlisting></informalexample><para id="_7_0_909">Refer to Spring's documentation for more
        information on the usage of the import element.</para></sect2><sect2 id="_7_0_910">
        <title id="_7_0_911">Heterogeneous configurations</title><para id="_7_0_912">In the introduction to this chapter, we evoked the
        possibility of configuring Mule with a scripting language. The tedious
        work of setting up the core runtime environment and all the
        boilerplate code this requires is usually enough to put off the
        bravest script aficionado. The good news is that there's a solution.
        It's possible to mix several styles of Mule configuration <indexterm id="_185_438_425"><primary id="_185_438_426">configuration</primary><secondary id="_185_438_427">modularity</secondary><tertiary id="_185_438_428">mixed format</tertiary>
          </indexterm>in an instance. The example in figure <xref id="_7_0_913" linkend="ch02_heter-conf_fig"/> shows an instance that
        has been configured with a Groovy script and Spring XML configuration
        builders. By following this approach, you can declare all the global
        elements using the XML syntax and focus your scripted configuration on
        the services you need for your integration project.<figure id="ch02_heter-conf_fig">
            <title id="_7_0_914">Mule can use heterogeneous builders to load a
            hierarchy of configuration files written in different
            syntax.</title><mediaobject id="_7_0_915">
              <imageobject id="_7_0_916">
                <imagedata fileref="figures/jeditXsdAssist.png" id="_7_0_917"/>
              </imageobject>
            </mediaobject>
          </figure></para><para id="_7_0_918">Since scripted configuration works at the bare
        metal level, you express the dependency to a parent by looking up the
        model you want to depend on. If in figure <xref id="_7_0_919" linkend="ch02_heter-conf_fig"/>, the common configuration defined a
        model named <code id="_185_438_429">commonModel</code>, the way the Groovy configuration <indexterm id="_185_438_430"><primary id="_185_438_431">configuration</primary><secondary id="_185_438_432">Groovy</secondary></indexterm>would look it up and use it would be the
        following:</para><informalexample id="_7_0_920"><programlisting id="_7_0_921" xml:space="preserve">model = muleContext.registry.lookupModel("commonModel")
...
childService.model = model</programlisting></informalexample><para id="_7_0_922">As you can see, there's no child model <emphasis id="_7_0_923">per se</emphasis>. It's up to the service in the child
        model to actively register itself in the model defined in the common
        configuration.</para><para id="_7_0_924">We're sorry to report that after reading this
        section, you have no more excuses for building monolithic and
        kilometric configuration files. And if you've inherited such
        configurations, you should now have some pretty good ideas on how you
        could refactor them.</para></sect2></sect1><sect1 id="_7_0_925">
      <title id="_7_0_926">Summary</title><para id="_7_0_927">In this chapter, you've learned the general
      principles involved in configuring Mule. You've discovered the overall
      structure of the Spring XML configuration, its syntax, and the ways to
      define properties values. Several strategies for organizing your
      configuration files have been detailed: they'll allow you to grow your
      integration projects without getting lost in lengthy and monolithic XML
      files.</para><para id="_7_0_928">The scripted configuration mechanisms have been
      rapidly covered as well. It's up to you to decide on your syntax of
      choice for configuring Mule. By looking at the examples at the end of
      this chapter, you should have a fair idea of the efforts involved in the
      XML and scripted configuration options. In the rest of the book, all the
      examples will use the Spring XML syntax.</para><para id="_7_0_929">In many places, this chapter has referred you to
      other chapters. Without this crafty stratagem, this chapter would've had
      the size of the whole book. The coming chapters will look further into
      the details of the main Mule moving parts: endpoints, routers,
      transformers, and components. You'll learn about the main types of each
      and all the good they can do for you.</para><note id="_7_0_930">
        <title id="_7_0_931">Before we close...</title><para id="_7_0_932">We'd like to introduce you to Clood,
        Inc. <indexterm id="_185_438_433"><primary id="_185_438_434">Clood, Inc.</primary><secondary id="_185_438_435">presentation</secondary></indexterm>, our fictional but promising startup specializing in
        the domain of value-added services for businesses hosting applications
        in the cloud. Blessed with a double O, our startup is bound for a
        great future and a significant IPO. On the technical side of things,
        Clood, Inc., decided to leverage Mule as our integration platform to
        support all the services (monitoring, deployment controls, identity
        management, DNS, and so on) we intend to offer to our clients.</para><para id="_7_0_933">We're happy to inform you that, always looking for
        a challenge and some stock options, you've decided to join us on this
        cloudy adventure. Throughout the rest of the book, we'll review some
        of our activities at Clood, Inc., and how we're using Mule to
        accomplish them.</para></note>
    </sect1>
    
    <bibliography id="_185_438_436">
    
    <biblioentry id="bib1">
      <abbrev id="_185_438_437">AhoSethiUllman96</abbrev>
      <author id="_185_438_438"><personname id="_185_438_439"><firstname id="_185_438_440">Alfred V.</firstname><surname id="_185_438_441">Aho</surname></personname></author>
        <author id="_185_438_442"><personname id="_185_438_443"><firstname id="_185_438_444">Ravi</firstname><surname id="_185_438_445">Sethi</surname></personname></author>
        <author id="_185_438_446"><personname id="_185_438_447"><firstname id="_185_438_448">Jeffrey D.</firstname><surname id="_185_438_449">Ullman</surname></personname></author>
      <copyright id="_185_438_450"><year id="_185_438_451">1996</year>
                 <holder id="_185_438_452">Bell Telephone Laboratories, Inc.</holder></copyright>
      <editor id="_185_438_453"><personname id="_185_438_454"><firstname id="_185_438_455">James T.</firstname><surname id="_185_438_456">DeWolf</surname></personname></editor>
      <isbn id="_185_438_457">0-201-10088-6</isbn>
      <publisher id="_185_438_458">
        <publishername id="_185_438_459">Addison-Wesley Publishing Company</publishername>
      </publisher>
      <title id="_185_438_460">Compilers, Principles, Techniques, and Tools</title>
    </biblioentry>
    
    <biblioentry id="bib2" xreflabel="Kites75">
      <abbrev id="_185_438_461">notKites75</abbrev>
      <author id="_185_438_462"><personname id="_185_438_463"><firstname id="_185_438_464">Andrea</firstname><surname id="_185_438_465">Bahadur</surname></personname></author>
        <author id="_185_438_466"><personname id="_185_438_467"><firstname id="_185_438_468">Mark</firstname><surname id="_185_438_469">Shwarek</surname></personname></author>
      <copyright id="_185_438_470"><year id="_185_438_471">1974</year><year id="_185_438_472">1975</year>
         <holder id="_185_438_473">Product Development International Holding N. V.</holder>
         </copyright>
      <isbn id="_185_438_474">0-88459-021-6</isbn>
      <publisher id="_185_438_475">
        <publishername id="_185_438_476">Plenary Publications International, Inc.</publishername>
      </publisher>
      <title id="_185_438_477">Kites</title>
      <subtitle id="_185_438_478">Ancient Craft to Modern Sport</subtitle>
      <pagenums id="_185_438_479">988-999</pagenums>
    </biblioentry>
    
    <biblioentry id="bib3">
      <abbrev id="_185_438_480">Walsh97</abbrev>
       <title id="_185_438_481">XML: Principles, Tools, and Techniques</title>
        <publisher id="_185_438_482">
          <publishername id="_185_438_483">O'Reilly &amp; Associates, Inc.</publishername>
        </publisher>
        <issn id="_185_438_484">1085-2301</issn>
        <editor id="_185_438_485"><personname id="_185_438_486"><firstname id="_185_438_487">Dan</firstname><surname id="_185_438_488">Connolly</surname></personname></editor>
      </biblioentry>
    
    </bibliography>
    

    
    
    </preface>
    </book>