:sourcedir: ../../code/src/main/java

[[chap04-getting-started]]
== Getting started with CDI

=== Understanding the concept of “Bean”

The concept of _bean_ is central to CDI. It is also quite complex, and the goal of this introduction is just to give you a first idea. Do not worry, nothing will be left in the shadow with the bean concept, we just feel that it is a bit too early to tell you everything about it.

First, a bean is a Java object. So, as all Java objects, it is an instance of a class. From this point of view, there is no difference between a plain Java object and a CDI bean. Of course things are going to change on this point. If not, what would be the point in creating such a complex framework as CDI?

As all Java Objects, a CDI bean has a type. An through the inheritance type system, it can have multiple types, given by a class and several interfaces. Of course CDI relies on the Java standard type system. So the type of a bean is its Java type at first. But CDI brings many refinements to the Java type system. In fact, the type of a CDI beans is built on its Java type, and special CDI annotations. CDI brings the possibility to create your own annotated types, thus the possibility to create your own type from scratch.

The second important point is that a CDI bean is provided by a CDI container. You should not create a bean by yourself in a CDI application. Merely, you should make a request on the CDI container to get an instance of a bean, just as in the factory pattern. In fact, CDI implements the factory design pattern on this point.

A consequence of that is that a CDI bean is bound to the CDI container that created it. It brings the notion of lifecycle, that will be seen in details later in this part. A CDI bean has a lifecycle, composed of several steps, each with its own callbacks. It allows a very fine control on the building of CDI beans, with many possibilities for your applications.

So a bean is an instance of a Java object, provided by a container (the CDI container). It can also be called a managed bean, since the container takes care of the creation of this bean. The container also provides many things for beans. Since this object is managed, the container can see everything we do with a managed bean. For instance, it can see that a method is called, thus allowing the interception of this call.

In the Java EE context, and for backward compatibility reasons, some special types of beans have been defined in the CDI context. We will see these beans in further details, let us just mention them here:

* All the Java EE resources defined at the Java EE container level. This is basically any resource accessible through JNDI. It includes for instance data sources, JMS queues, and also any global variable. Some of those resources may also be accessible through other means.
* Persistence units and persistence contexts are exposed through special beans. A persistence unit bean is of type `EntityManagerFactory`, and a persistence context bean is of type `EntityManager`. In the Java EE context, an`EntityManager` is bound to a transaction.
* EJBs are also special beans in the Java EE context. EJB are defined in their own Java EE specification, and carry special semantics regarding how their methods are called.
* Web services are the last special type of beans handled by CDI in the Java EE context.

==== Definition / metadata / instance

It is very simple to define a simple bean in CDI. But the overall, complete process, is very complex. It relies on many notions that needs to be explained one by one before you can understand everything.

In the early versions of CDI, the bean definitions were carried in XML metadata, namely in a `beans.xml` file. Since version 1.2 this XML file has been made optional, everything can be done using annotations. For backward compatibility reasons, the `beans.xml` file is still there, and still supported. For some cases it is still needed: not everything can be done with annotations. But in many cases, we do not need it anymore.

==== Bean archive

The notion of bean archive is the first notion to understand if you want to build a working CDI application. That is, an application that relies on the use of a CDI container. This notion is used by the CDI container. A CDI container analyzes the content of a bean archive, looking for its supported annotations and descriptors. It then builds the object graph that your application will use. A JAR or any other archive is the most general sense that is not a bean archive is not analyzed
 by CDI.

Most of the time, when you get a CDI error telling you that your bean is not known, or has not been discovered, it comes from an archive problem: the JAR with the faulty bean has not been analyzed by CDI. So understanding how a bean archive works is important prior to understanding anything else in CDI.

Once again, we must consider two cases: the case of a CDI application that is part of a Java EE application, and the case of a standalone CDI application.

In all cases, an archive is a classical Java language notion. An archive can be:

* a JAR file on the Java SE world, or
* an EAR, a WAR, or a RAR in the Java EE world.

Those are the classical examples of archives. But it can also be a directory on the classpath, including the `WEB-INF/classes` special directory of a web archive. This special directory can be in a WAR file, but not necessarily.

So what makes a Java archive, a CDI bean archive? The answer is simple: the presence of a special file, the `beans.xml` file. Where should this file be put? There are several places for it. In the Java SE world, it should be put in the `META-INF` directory of an archive. Remember, in the Java SE world, an archive can be a JAR or a directory on the classpath.

It the Java EE world, there are other kind of archives, so more places to put a `beans.xml` file. But basically the rule is the same: the `beans.xml` file should be put in a `META-INF` directory. There is one exception to this rule though. In the case of a WAR archive, the `beans.xml` file can also be put in the `WEB-INF` directory directly.

What probably comes to mind now is: what happens if we have more than one `beans.xml` file? The answer is quite simple, and there are indeed error cases.

In both the Java SE and Java EE cases, as long as an archive (in the Java sense) has only one `beans.xml` file, everything will be handled properly. An error case can be raised if a configuration has more than one `beans.xml` file in one given
archive.

===== The Web archive (WAR) case

The case of the WAR is quite complex, since there are several places where the `beans.xml` can be put. Usually a WAR relies on home made classes, that can be packaged in JAR files put in the `WEB-INF/lib`, or put directly in the `WEB-INF/classes`. Thus it is logical to enable to put the `beans.xml` file in the `WEB-INF/classes` directory.

On the other hand, if you want to build a WAR that depends on JAR files that already contain `beans.xml` files, you will probably want to be able to override the definitions from those files. Taking into account the  `beans.xml` file from the `WEB-INF/classes` directory would not make sense: it would give a global scope to something defined locally. So the decision has been taken to allow  a global `beans.xml` file in the `WEB-INF` directory.

In a nutshell, the `beans.xml` can be put:

* in the `WEB-INF` directory
* in the `WEB-INF/classes/META-INF` directory
* in the `META-INF` directory of any JAR put in the `WEB-INF/lib` directory.

If a `beans.xml` file is found in the `WEB-INF` directory, then it overrides the `beans.xml` files that can be found in the JAR files of the `WEB-INF/lib` directory.

If a `beans.xml` file is found in the `WEB-INF/classes/META-INF` directory, then the `WEB-INF/classes` is considered a bean archive by CDI. The classes from this directory will be analyzed by the CDI container.

If two `beans.xml` are found in both the `WEB-INF` directory and the `WEB-INF/classes/META-INF` directory, then an error is raised. As a web archive designer, you should not be doing that.

Of course, any JAR from the `WEB-INF/lib` that contains a `beans.xml` file in its META-INF` directory is a bean archive.

If a `beans.xml` file is found in the `WEB-INF` directory, it overrides all the `beans.xml` files that could be found in the JAR of the `WEB-INF/lib` directory.


===== The EJB JAR case

An EJB JAR is a special kind of JAR that contains EJB. It can contains a descriptor file: the `ejb-jar.xml` file. This file has been made optional in EJB 3.0, since the information is contains can now be setup in the EJB annotations.

If this file is present, it should be put in the `META-INF` directory of the EJB JAR archive.

Normal rules apply to this archive. Thus, it is a bean archive if it has a `beans.xml` file in its `META-INF` directory. In that case, the content of this archive, and all the archives it depends on will be analyzed by the CDI container.

===== The Connector archive (RAR) case

A RAR archive file contains Java EE connectors used to access enterprise information system. Typically, one such connector exists for each type of resource needed by a Java EE resource. The architecture of the Java EE platform defines the notion of Java EE Connector, the Java EE standard for such adapter components. Those components are packaged in a special archive file: the RAR file.

In this case, the CDI container looks for all the JAR that this RAR depends on. All the previous rules stand in telling if a JAR is a bean archive or not. There is no `beans.xml` file defined at the RAR level, as it is the case for the WAR file.

===== The Enterprise archive (EAR) case

An Enterprise Archive can contain any kind of archive previously defined: JAR, WAR or RAR. Some of those JAR have a special semantic: they are called EJB JAR.

All the previous rules stand for the archives that an EAR depends on.

The EJB JAR files need to have a `beans.xml` file to be considered as bean archives and thus analyzed by the CDI container.

There is no `beans.xml` file defined at the EAR level, as it is the case for the WAR file.


===== Embedded EJB

An embedded EJB container uses a system property called `javax.ejb.embeddable.modules`. This property works as a classpath, and defines all the archives this EJB container depends on. If this property is not defined, then the classpath is used instead of this property.

In the case of an embedded EJB container, all the java archives are seen as bean archives.


===== What happens if a class is present in more than one archive?

Enterprise applications may be so complex that it becomes more and more frequent to have classes present in more than  on archive. This is especially true for outside dependencies. It is nor rare to see a given library present more  than once in the dependency tree of an application, sometimes with different version numbers!

If a class is present in more than one bean archive, then non defined behavior will occur. You may have different behaviors with different CDI implementations. In one word: avoid this case at all cost!


=== Writing your minimal CDI application

Now that we have gone through the complex rules of making a Java archive a bean archive in the CDI sense, what about building a first, simple bean archive?

==== The content of the `beans.xml` file

First, we need a `beans.xml` file. We have talked a lot about where to put this file so that our CDI application will work, but we still need to write such a file.

The `beans.xml` is a very simple XML file. Let us see a first example.

[[app-listing]]
[source,xml]
.A first beans.xml file for CDI 1.0
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                           http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>


It is indeed a very classical XML file. The namespace is `http://java.sun.com/xml/ns/javaee` and the schema location is `http://java.sun.com/xml/ns/javaee/beans_1_0.xsd`.

Be careful, because between version 1.0 and 1.1 something odd happened: the namespace changed and the location of the XML schema changed also. Let us have a look at those new values right now.

[[app-listing]]
[source,xml]
.A second beans.xml file for CDI 1.1 and CDI 1.2
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                           http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd">
</beans>


So if you need to migrate a CDI 1.0 application to a more recent version, you know what to do with your `beans.xml` files.

Now you could think that the XML Schema for CDI 1.2 is `beans_1_2.xsd` at the same address than the previous version. In fact there is no such `beans_1_2.xsd` schema. CDI 1.2 is a maintenance release, the schema has not been modified.


==== Version and bean discovery mode

The root element of this file is `beans`. In CDI 1.0 it has no attribute defined. This changed in CDI 1.1, where two attributes were introduced:

* `version`, set to 1.1 by default;
* `bean-discovery-mode`, which is mandatory.

This `bean-discovery-mode` may take three values: `annotated`, `all` and `none`. Let us see that in details.

The bean discovery mode `none` means that no type from this archive will be analyzed. This bean archive is just empty. You may wonder what is the purpose of adding a `beans.xml` file in an archive to make it a bean archive, and then to tell CDI: dont do anything with this! There is indeed a case where we need this kind if thing. Remember that in web archives, you may have JAR in your `WEB-INF/lib` with `beans.xml` files in them. If you do not want them to be seen as bean archives, then you can put a `beans.xml` file in your `WEB-INF` directory that will override those  local `beans.xml` files. And in this global `beans.xml` file, you can set the bean discovery mode to none to shut down everything.

The bean discovery mode `annotated` means that only the annotated types will be considered by CDI. This is the recommended value. It just works as you expect it. All your annotated beans will be taken into account by the CDI container.

The last mode is the `all` mode and you should be very careful with it, because all the types in the archive will be used by the CDI container. So if you have crafted your archive very carefully and you know that indeed all your types are CDI types, then you can use it. In all the other cases, use the `annotated` mode.

There are no other attributes added to this `beans` element. We will see the subelements later in this chapter.


==== Bootstrapping Weld

As we already explained, a CDI application needs a container to work. This container is in fact an implementation of CDI. Weld is the reference implementation for CDI. This container is production ready, and used in supported application servers. 

To use Weld in a Java SE environment we need to add the following dependencies to our Maven project.

[[app-listing]]
.Maven dependency to bootstrap Weld 2
[source,xml]
<dependency>
    <groupId>org.jboss.weld.se</groupId>
    <artifactId>weld-se</artifactId>
    <version>2.2.15.Final</version>
</dependency>

The version used here is the 2.2.15.Final, which is the current version as of the writing of this book. Weld V2 supports CDI 1.2.

Bootstraping Weld is done by using the following pattern. We have written it in a `main` method for the sake of simplicity.

[[app_listing]]
.A minimal code to bootstrap Weld 2
[source,java]
----
package chap04;

import org.jboss.weld.environment.se.Weld;
import org.jboss.weld.environment.se.WeldContainer;

public class BootstrapingWeld {

    public static void main(String... args) {

        Weld weld = new Weld();
        WeldContainer container = weld.initialize();

        weld.shutdown();
    }
}
----

Of course this code does not do much. It basically creates the Weld container, and shuts it down.

And in fact if you run this code as is, you will get an error telling you that Weld is missing the `beans.xml` file. We need to add the following file.

[[app_listing]]
.The needed `beans.xml` file
[source,xml]
----
include::{sourcedir}/META-INF/beans.xml[]
----

This time, running the previous code should not raise any error. Note that the `beans.xml` file should be put in the `META-INF` directory of your project. If you are using Maven (as we are in this book) and did not modify the standard directory structure of the Maven project, the right place to put it is the `src/main/resources` directory. It will also work if you put it in `src/main/java`, but the JAR generated by Maven will not be built properly: it will not contain your `beans.xml` file.

Now we have a Maven project properly set up, let us add some CDI magic to it.

We used a simple example in the first part of this book. It was about posting messages to a repository. We used two classes: `PostService` and `PostRepository`. This is a simplified version of the example, where we do not consider the users.

We have basically three very simple Java elements: one class and two interfaces.

The first class is the `Post` class, used as a payload in our system. We removed the `User` class, for the sake of simplicity. You can add a `toString()` method to this `Post` class if you want to trace things in the example code.

[[app_listing]]
.The `Post` class
[source,java]
----
package chap04.model;

public class Post {
}
----

The we have a `PostService` interface, that defines what we can do with posts. Our system is still very simple, we can only save posts in a repository.

[[app_listing]]
.The `PostService` interface
[source,java]
----
package chap04.service;

import chap04.model.Post;

public interface PostService {

    public void post(Post post);
}
----

And then we need to define a `PostRepository` interface, to save our posts in some kind a persistent backend. It could be a XML repository, a relational database, a NoSQL database, whatever.


[[app_listing]]
.The `RepositoryService` interface
[source,java]
----
package chap04.repository;

import chap04.model.Post;

public interface PostRepository {

    public void save(Post post);
}
----

Now we have a well-designed system that compiles properly. Of course, if we want it to save posts, we will need to provide implementations for our interfaces.

The implementation of the `PostService` interface relies on the `PostRepository` interface.

[[app_listing]]
.The `PostServiceImpl` interface
[source,java]
----
package chap04.service;

import chap04.model.Post;
import chap04.repository.PostRepository;

import javax.inject.Inject;

public class PostServiceImpl implements PostService {

    @Inject
    private PostRepository postRepository;

    @Override
    public void post(Post post) {
        postRepository.save(post);
    }
}
----

What is this `@Inject` annotation? Well, it is the first trace of the CDI magic we talked about earlier. It tells the CDI container (which is in fact a Weld container in this example): find a concrete class for the `PostRepository`, instantiate it, and when I call the `post()` method, I want that instance in the `postRepository` field.

CDI is very smart, but there are things it cannot do. First, it cannot build a concrete class of `PostRepository`. So we need to give it one. Here we go. Let us first write a simple in memory implementation of our `PostRepository` interface.

[[app_listing]]
.The `InMemoryPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.HashMap;
import java.util.Map;

public class InMemoryPostRepository implements PostRepository {

    private long id = 0L;
    private Map<Long, Post> posts = new HashMap<>();

    @Override
    public void save(Post post) {
        long id = this.id++;
        posts.put(id, post);
    }
}
----

This implementation will do the job in very simple cases. It is not concurrent aware, so we should not call this class from multiple threads. If we do, we will certainly lose posts, and most probably corrupt our repository. So do not use such a naive implementation in production! But for your first, simple example, it will be enough. Once again, you can add a `toString()` method if you want to trace things precisely.

Second, it needs to be able to instantiate a class using the Java reflection API. We need to keep that in mind, and build implementation classes with empty constructors. In fact, there are cases where CDI can use another constructor than this one. But we need to explain it how to do that. We will see this technique later in this book.

Notice that our system is programmed with interfaces and not directly with classes. This is a good practice. It you are aware of the SOLID design principle, programming against interfaces follows the L principle, that is the Liskov substitution principle.

At this point, we have a very simple, but fully working CDI application. Let us write the code to run it.

[[app_listing]]
.The `Main` class
[source,java]
----
package chap04;

import chap04.model.Post;
import chap04.repository.PostRepository;
import chap04.service.PostService;
import org.jboss.weld.environment.se.Weld;
import org.jboss.weld.environment.se.WeldContainer;

public class BootstrapingWeld {

    public static void main(String... args) {

        Weld weld = new Weld();
        WeldContainer container = weld.initialize();

        PostRepository repository =
            container.instance().select(PostRepository.class).get(); // <1>
        PostService postService =
            container.instance().select(PostService.class).get();

        postService.post(new Post()); // <2>

        weld.shutdown();
    }
}
----
<1> this is the pattern to get an instance of a CDI bean
<2> the CDI magic is at work behind this line of code: no null pointer exception, the post is correctly saved

This example will work if we set the `bean-discovery-mode` to `all`. If we keep the recommended value (that is `annotated`), CDI will not be able to see the implementations of the classes we created.

Let us browse through all what CDI did for us.

* It could scan our classpath, and associated the implementations of `PostService` and `PostRepository` to their own interfaces.
* When we asked for an implementation of those interfaces, it was able to create one, without any help from us.
* It was able to set the annotated field with an instance of the right interface, once again, without any help from us.
* When we ran our example, it just worked as expected.

All these we barely any configuration.

=== Injection points

We had a first glimpse at what dependency injection is in CDI: a field of a bean was annotated with `@Inject`. And we saw that CDI used this annotation to create a bean and store it in the annotated field.

Let us see more details about this `@Inject` annotation right now, because we are going to use it a lot in the rest of this book. We need to keep in mind the context in which CDI will use this annotation. At some point, CDI needs to create an instance of a bean. If this bean as a state, that is, if it has fields, then CDI needs to check if those fields need be initialized with some values. To tell that, it will look for this `@Inject` annotation.

The first example we saw is probably the simplest one: putting `@Inject` on a field. CDI will find how to build a bean of the right type to match the one of this field, create an instance of this bean, and store it in the field. Easy and simple.

There are two other possibilities.

The first one is to put this `@Inject` annotation on a constructor. In this case, CDI will use that constructor to build an instance of this bean. All the parameters of this constructor (it can have more than one) will have to be resolved by CDI. In other words, CDI will have to build instances of the right type for each of those parameters. We will see an example of such a case, with more details. Let us just say here that injecting through a constructor can only be done on one constructor among all the constructors this class may have.

And the second one is to put the `@Inject` annotation on a method. The simplest case is a setter method. In this case, it really looks like annotating the corresponding field, the only difference being: in that case CDI calls the setter instead of setting the value of this field directly using the Java Reflection API. But it is not the only case supported by CDI. In fact, any method with any number of parameters can be annotated by `@Inject`, thus becoming an _initializer_ method. As it is the case for the annotated constructor, all the parameters of the this method have to be resolved and injected.

A given class may have any number of initializer methods, all of them will be called by CDI as part of the bean initialization process. Note that an initializer method can be private, protected, public or package protected. It cannot be abstract, and certainly not static.

So in a nutshell, this `@Inject` annotation can be put on three elements:

* fields
* one constructor of the class
* any number of methods (including zero), that become _initializer_ methods.

In all cases, CDI needs to resolve the elements been injected. If it cant, then an error will be raised.

=== Producing home made beans

We can go in several directions from this point. Let us choose one: how can we tell CDI that is should not rely on the default instantiation of a bean to create an instance. Suppose we have a special process that we want to use to create our own instance of a bean.

This is where the notion or producer is used. CDI knows that it should set the value of a field because it is annotated with the `@Inject` annotation. We can also use a `@Produce` annotation to tell it how to create an instance of a given bean.

Let us show this on an example. Suppose that our `InMemoryPostRepository` needs a parameter to be built: namely the size of the underlying `HashMap` used to save our posts.

[[app_listing]]
.The `InMemoryPostRepository` class with no empty constructor
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

The main difference between this version of this class and the previous one is that CDI cannot build it on its own. Why? Because the empty constructor that was present in the previous version is not here anymore. So CDI cannot rely on the Java reflection API to build instances of this bean. And indeed, if we run our example again, we get this error message.

[[app_listing]]
.Error met with a bean with no empty constructor
[source,txt]
----
Exception in thread "main" org.jboss.weld.exceptions.DeploymentException: WELD-001408: Unsatisfied dependencies for type PostRepository with qualifiers @Default
  at injection point [BackedAnnotatedField] @Inject private chap04.service.PostServiceImpl.postRepository
  at chap04.service.PostServiceImpl.postRepository(PostServiceImpl.java:0)
----

Since CDI could not find a way to build an instance of the `PostRepository` type, it could not build the `PostService` neither.

How can we solve that? In fact there are three ways of solving it.

==== Annotated constructor

First, we can annotate the constructor CDI should use with the `@Inject` annotation.

[[app_listing]]
.Annotating the constructor of the `InMemoryPostRepository` class
[source,java]
----
public class InMemoryPostRepository implements PostRepository {

    private Map<Long, Post> posts;

    @Inject
    public InMemoryPostRepository(int size) {
        posts = new HashMap<>(size);
    }

    // the rest of the class is not touched
}
----

Of course, if our class has several constructors, only one should be annotated. If more than one constructor is annotated, then CDI will raise an error.

CDI will then call this constructor to build an instance of `InMemoryPostRepository`, and will need values for the parameters of this constructor. These parameters will have to be injected, so CDI will look for values for them. If it cannot find ways to build them, an error will be raised. The example we just wrote is very naive, and we will have trouble to make it work, because CDI will have trouble finding an `int` value to inject in this constructor. So in this particular case, using an annotated constructor is certainly not the best way to go! Do not worry, we are going to see others.

==== Using a producer

Providing a _producer_ to tell CDI how to create the missing instance is another possibility, and in our case, the right one.

What is a `Producer`? It is just an annotation put on something CDI will use to create an instance of a type. Here CDI needs to create an instance of the `PostRepository` type, so we need to annotate such a way.

The `@Producer` annotation can be put on several elements of a class.

* It can be put on a method. This method should return an instance of the right type. CDI will call this method to get that instance and use it.
* It can also be put on a field. This time, CDI will simply read that field to get that instance.

Let us see examples of those two cases.

==== Producer methods

So let us add the following class to our example.

[[app_listing]]
.The `PostRepositoryProducer` class
[source,java]
----
package chap04.producer;

import chap04.repository.InMemoryPostRepository;
import chap04.repository.PostRepository;

import javax.enterprise.inject.Produces;

public class PostRepositoryProducer {

    @Produces // <1>
    public PostRepository buildPostRepository() {
        return new InMemoryPostRepository(16);
    }
}
----
<1> Putting the `@Producer` annotation here informs CDI that it should call this method to build instances of `PostRepository`

If we run our example again, the error message is gone.

Note that a producer method (that is, a method annotated with `@Produces`) is one way among others for CDI to build a bean. If we add an explicit no-arg constructor to our `InMemoryPostRepository` class, then CDI will have two ways to build an instance of `PostRepository`, leading to an ambiguous dependency, and another error. We will see ways of dealing with this later in this chapter

A producer method can be nearly any kind of method. It can be static or non-static, private, protected, public or package protected. It should be _seen_ by CDI, so it should be a method of a managed bean, or a method of an EJB.

A producer method might return a null value. Of course in that case, odd things may happen. This is still possible, and handled by CDI. There are restrictions though, that we will see later in this book.

A producer method may have parameters. Since this method is called by CDI, those parameter have to be injected. So all the parameters of a producer method are treated as injection points when CDI calls this method.

==== Producer fields

The `@Produces` annotation can also be put on a field. This may looks odd, because a method call may look so much logical! There is in fact one case where it is extremely useful: the case where this field is itself injected. Let us look at the following example.

[[app_listing]]
.An injected producer field
[source,java]
----
@Stateless
public class PostEJB {

    @PersistenceContext(unitName="PostPersistenceUnit") @Produces
    private EntityManager entityManager;

    // rest of the class
}
----

The field `entityManager` if an EJB field, due to the `@Stateless` annotation. So the Java EE container will set the `entityManager` field prior to any method call on this EJB. It is in fact the recommended way of getting a JPA entity manager in a Java EE context.

The fact is: we can use this field to create a CDI producer, just by putting the `@Produces` annotation on this field.

This pattern is extremely useful to add any kind of Java EE resource (whether it is a datasource, a web service, a JMS queue) to a CDI application and use it directly.

This pattern can be used in any application: an injected field can become itself a producer for other types.

=== What is the type of a bean?

==== Bean types are Java types

So far we saw that CDI is able to associate producers and injection points based on the type of both. In a nutshell, an `EntityManager` producer will be used to create `EntityManager` beans, and to inject an `EntityManager` injection point.

Let us take a closer look at this notion of bean type, because it is a bit more tricky than it seems, especially in the Java EE world.

For instance, our `InMemoryPostRepository` has the following definition.

[[app_listing]]
.Types of the `InMemoryPostRepository` class
[source,java]
----
public class InMemoryPostRepository
implement PostRepository {

    // content of the class
}
----

From the Java type sytem point of view, this class has two explicitly defined types: `InMemoryPostRepository` and `PostRepository`. And CDI will follow this, so this bean can be injected in the two corresponding types of injection points.

But this class also extends the `Object` class, as it is the case for all the Java classes. And indeed, CDI recognizes that. So if you have an injection point of type `Object`, it can be injected with an instance of the `InMemoryPostRepository` class. Of course, you should not do that, because an injection point of type `Object` can be injected with so many types that you will probably in trouble.

So we can see that the types seen by CDI are in fact the plain Java types.

In fact, a bean type may be the following.

* Any interface, class or abstract class can be a CDI Bean Type.
* Any parameterized Java type, as long as the parameter has a defined value. For instance `List<String>` is a legal CDI Bean Type, whereas `List<E>` is not.
* Any raw type is a legal CDI Bean Type. For instance, `List` is the raw type of `List<E>` and is a legal CDI Bean Type.
* Any array of legal type is a legal CDI Bean Type.
* Any primitive type is also a legal CDI Bean Type.

All the other types are not legal CDI Bean Type, in particular, types parameterized with wildcards are not legal.

==== Bean Types of a bean produced by a producer method or field

The CDI Bean Type of a bean produced by a producer method or field is fixed by the returned type of this producer method, or the type of this field.

There are three cases to consider.

* If the defined type of the producer is an interface, then the CDI Bean Type is the set composed of this interface, all the super-interfaces if any, and the `Object` type, which is always there.
* If the defined type of the producer is a class, then the CDI Bean Type is the set of composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces if any, and their super-interfaces if any.
* And if the defined type of the producer is an array or a primitive type, then the CDI Bean Type is the set composed of this array or primitive type, and the `Object` type.


==== Bean types in the Java EE world

The Java EE world brings three notions that have an impact on the definition of CDI Bean Types.

===== The case of Resources

Resources are elements that may be defined outside of a Java EE application itself. There are usually defined at the Java EE application server level. Think of a JMS queue, a database connection, that can be exposed through a `DataSource` or a JPA `EntityManager`. In fact an `EntityManager` is bound to a transaction more than a database connection, but this is the object with which interact in a Java EE code.

Java EE allows for the injection of such resources in our code, through annotated fields or setters. Those objects are injected either through fields or method parameters.

The CDI Bean Type of such an injected resource in simply the CDI Bean Type of the injected field or parameter. Most of the time, the declaration of this field or parameter will be an interface. We already defined the CDI Bean Type of an interface, it is simply the set composed of this interface and all its super-interfaces, and the `Object` type.

===== The case of Managed Beans

The case of managed beans has also been seen. This managed bean has a defined class, so the CDI Bean Type of this managed bean is the set composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces and their super-interfaces.

===== The case of Session Beans

The case of the session beans is a bit more complex, since we need to understand how a session bean exposes its type to the Java EE container.

In Java EE 5 and before, a session bean was exposed through an interface, that could be declared local or remote. This is still the case bytheway, since it is possible to expose a session bean to remote calls. So in this case, CDI treats this bean as an interface instance, and the rules pertaining to interfaces hold. Thus, such a bean has a CDI Bean Type composed of this interface, all the super-interfaces, and the `Object` type.

When Java EE 6 was released, this constrain of having an interface for a session bean has been relaxed. Now a session can also be a simple annotated class, with no defined interface. Of course this kind of bean cannot be accessed remotely. In that case, CDI treats this bean as a class instance, and the rules pertaining to classes hold. Thus, such a bean has a CDI Bean Type composed of this class, all its super-classes including the `Object` class, and all the implemented interfaces, and their super-interfaces.


=== Defining a first CDI bean: choose your bean type using Qualifiers

Probably the first question that comes to mind at this point is the following: what happens if I have more that one implementation for a given interface? CDI will probably be in trouble to choose from those implementations. It is quite easy to test that, so let us do it, and write another implementation for our repository. This time we will not repeat the mistake we did: it will be concurrent aware!

[[app_listing]]
.A second, concurrent aware, implementation of the `PostRepository` interface
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

public class InMemoryConcurrentPostRepository implements PostRepository {

    private AtomicLong id = new AtomicLong(0L);
    private ConcurrentMap<Long, Post> posts = new ConcurrentHashMap<>();

    @Override
    public void save(Post post) {
        long postId = id.getAndIncrement();
        posts.put(postId, post);
    }
}
----

What happens if we run the same code, without any other modification? Well, it does not work too well. In fact, an error is raised, which is the following.

[[app_listing]]
.Error raised for two implementations of the same interface
[source]
----
Exception in thread "main" org.jboss.weld.exceptions.DeploymentException: WELD-001409: Ambiguous dependencies for type PostRepository with qualifiers @Default
  at injection point [BackedAnnotatedField] @Inject private chap04.service.PostServiceImpl.postRepository
  at chap04.service.PostServiceImpl.postRepository(PostServiceImpl.java:0)
  Possible dependencies:
  - Managed Bean [class chap04.repository.InMemoryPostRepository] with qualifiers [@Any @Default],
  - Managed Bean [class chap04.repository.InMemoryConcurrentPostRepository] with qualifiers [@Any @Default]
----

There are details that we cannot understand yet in this error message, we will see all these later in this part. But in a nutshell, CDI complains because it sees two possible implementations for the `PostRepository` dependency, and has no rule on which one to choose from.

How can we explain to CDI which bean to choose from when more than one type (here `InMemoryPostRepository` and `InMemoryConcurrentPostRepository`) matches the type we need, namely `PostRepository`? This is what we are going to describe now.

In fact there is already a hint in the error message. If we read the error message carefully, it tells us that there is more than one bean of type `PostRepository` with qualifier `@Default`. Indeed, a _qualifier_ is a CDI notion that is there to bring more semantic to a Java type. CDI sees this semantic and can tell two beans that have the same Java type. Thus, CDI can choose which bean should be used, with this qualifier.

CDI defines a default qualifier: `@Default`. All the beans have this qualifier, thus the presence of this reference in the error message.

==== Using a qualifier on a simple example

A qualifier is a very simple Java element: it is just an annotation.

This annotation can be put along with the `@Produces` annotation. This is a very simple way to tell CDI that this field or method produces elements qualified by the annotation we put. Let us see a simple example.

We saw that we could inject persistence contexts in an EJB field. Suppose we have two databases: one for our posts, and another one for our users. We then have two different persistence contexts, since one persistence context can access to one database.

[[app_listing]]
.An EJB with two entity managers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    private EntityManager userEntityManager;

    // rest of the class
}
----

If we use those two fields as CDI producers, we will get an error, since the type of those fields is the same: `EntityManager`.

We need to add semantic, telling CDI exactly what are those fields: the first one deals with posts, and the second one with users. This is exactly what qualifiers are for.

[[app_listing]]
.An EJB with two entity managers, and qualified producers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    @Produces @DBPost
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    @Produces @DBUser
    private EntityManager userEntityManager;

    // rest of the class
}
----

On this second example, we put the `@Produces` annotation on each field, making them CDI produces. Along with the `@Produces` annotation, we add another annotation `@DBPost` and `@DBUser`. Those annotations are qualifiers, and CDI uses them to tell `postEntityManager` from `userEntityManager`. We will see in a moment how these annotations are built.

The rest is very easy to guess: we use the exact same way to qualify an injection point, so that CDI can tell which bean it should put in that field.

[[app_listing]]
.Injection with a qualifier
[source,java]
----
public class PostService {

    @Inject @DBPost
    private EntityManager entityManager;

    // rest of the class
}
----

On this last example, CDI knows that is should inject the entity manager qualified by `@DBPost`.

==== Writing a qualifier

This is all great, there is just one element missing: how does CDI know that those annotations we used, `@DBPost` and `@DBUser` are qualifiers? We know how to write annotations in Java, but what CDI magic makes an annotation a qualifier?

Well, there is indeed some kind of magic here, called meta-annotation. A qualifier is an annotation (no doubt about that!) itself annotated by a special CDI annotation: `@Qualifier`. This annotation has to be seen by CDI, so it has to be put in a bean archive. When CDI sees that this annotation is annotated by `@Qualifier`, it records it as such, so that we can use it in our code.

Let us create `@DBPost`, since we need to be able to use it.

[[app_listing]]
.Defining the `@DBPost` qualifier
[source,java]
----
import javax.inject.Qualifier;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Qualifier // <1>
@Retention(RetentionPolicy.RUNTIME) // <2>
@Target({ElementType.METHOD, // <3>
         ElementType.FIELD,
         ElementType.PARAMETER,
         ElementType.TYPE})
public @interface DBPost {
}
----
<1> This is the annotation CDI needs to tell that `DBPost` is a qualifier
<2> Of course a qualifier is analyzed by CDI when we launch our application, se we need it at runtime
<3> those are the Java elements we can put our `DBPost` annotation on. This list has to be compatible with `@Produces` and `@Inject`, since a qualifier has to be put with those two annotations.

A qualifier might look a little tricky to create. The use of this meta-annotation is not a very common pattern. The fact is: CDI relies a lot on annotations, and uses this pattern in many places. So this is the right time to get used to it. In fact it is quite easy to follow. Just create the annotation you need, add this special CDI annotation to it, `@Qualifier` in our example, and that is all you need to do.

===== Qualifiers with attributes

It is legal for a qualifier to define attributes. In that case, CDI will compare the two annotations along with the values of their attributes. Those values are compared with their respective `equals()` method, as we expected.

A qualifier may also define attributes that are not taken into account in the comparison. In this case, this attribute should be annotated with `@Nonbinding`.

In the case an annotation attribute type is an array, then it should be annotated with `@Nonbinding`. If not, then non predictable or implementation dependent results will occur.

Let us see that on an example. We could have created one annotation `@DB` with a default value to tell from the user database and the post database.

[[app_listing]]
.Defining the `DBType` enumeration
[source,java]
----
public enum DBType {

    POST, USER
}
----

[[app_listing]]
.Defining the `DB` qualifier, with a `DBype` attribute
[source,java]
----
import javax.enterprise.util.Nonbinding;
import javax.inject.Qualifier;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Qualifier // <1>
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,
         ElementType.FIELD,
         ElementType.PARAMETER,
         ElementType.TYPE})
public @interface DB {

    DBType value(); // <2>

    @Nonbinding String comment() default ""; // <3>
}
----
<1> The definition of this qualifier is the same as the previous one
<2> Here we declare the `value()` attribute
<3> And here the `comment()` attribute, which is made optional

So we can now use this qualifier on the produce side in this way.

[[app_listing]]
.Redefining the entity manager producers
[source,java]
----
@Stateless
public class PostAndUserEJB {

    @PersistenceContext(unitName="PostPersistenceUnit")
    @Produces @DB(DBType.POST) // <1>
    private EntityManager postEntityManager;

    @PersistenceContext(unitName="UserPersistenceUnit")
    @Produces @DB(value=DBType.USER, comment="This is the User DB") // <2>
    private EntityManager userEntityManager;

    // rest of the class
}
----
<1> We do not need to tell that its attribute is the `value()` attribute, due to the way annotations work in Java
<2> Since we set a non-default value for the `comment()` attribute, we need to tell that `DBType.USER` is the value of the `value` attribute

==== Injecting by type, injecting by qualifier

CDI has in fact two ways of telling which bean should be injected where.

It can discriminate beans based on their Java type. But soon, you will discover that this is not enough. We saw it on the entity manager example. On one hand, we have the `EntityManager` type, and on the other hand we have different databases that cannot be discriminated solely on the type of the injected object.

So we need more information, and this information is brought by qualifiers. A qualifier can be seen as an element that is there to add the piece of information we need along with the type of a bean. It tells CDI that this injection point needs an `EntityManager` that points to our user database for instance.

==== Qualifiers of a bean

The notion of qualifier is of course linked to the notion of bean. We say, in the CDI context, that a bean has qualifiers. But this is quite an abstract notion, because we never really see this bean. What we see is where and how it is produced, and where and how it is used, or injected.

In fact, a bean has all the qualifiers defined on its producer method, plus a number of qualifiers CDI adds with certain default rules that we are going to see. This defines the qualifiers possessed by a bean.

And on the other hand, when we use a bean, that is, when a bean is injected in our code, this qualifier is bound to have a set of qualifiers defined on the injection point.

So this notion of qualifier can be seen from three points of view:

* the qualifiers that a bean has
* the qualifiers defined at the producer lever
* the qualifiers defined at the injection point

===== Adding a qualifier on a producer

We saw that a producer could be a method or a field, thus adding a qualifier on those two elements makes perfect sense.

===== Adding a qualifier on a type

We also saw that CDI sees the `InMemoryPostRepository` and `InMemoryConcurrentPostRepository` classes as two possible instances of the `PostRepository` interface, without any kind of information, metadata or configuration from us. It is its default behavior. To tell those two implementations, we can add a qualifier directly on the classes themselves. This pattern will be the following.

[[app_listing]]
.Qualifying types
[source,java]
----
@SimpleRepository
public class InMemoryPostRepository implements PostRepository {
    // content of the class
}

@ConcurrentRepository
public class InMemoryConcurrentPostRepository implements PostRepository {
    // content of the class
}
----

The two annotations `@SimpleRepository` and `@ConcurrentRepository` are two qualifiers that CDI uses to tell those two implementations. Using them on the injection points will tell CDI which one to use on which place.

===== Qualifiers on the injected constructor

We also saw the case of a CDI bean that has no empty constructor, due to the presence of one or more constructors with arguments. We saw that one of those constructors can be annotated with `@Inject`, allowing CDI to use this constructor to build this bean using this constructor. And at last, we saw that, in this case, all the parameters of this constructor are injected by CDI, since it is CDI itself that calls this constructor.

We do not need to annotate those parameters with `@Inject`, since this is the default CDI behavior. But we can put qualifiers on them. CDI will use those qualifiers to tell which bean it should inject. The pattern is the following.

[[app_listing]]
.Qualifying injected parameters
[source,java]
----
public class PostServiceImpl implements PostService {

    @Inject // <1>
    public PostServiceImpl(
        @ConcurrentRepository postRepository) { // <2>
        // content of the constructor
    }

    // rest of the class
}
----
<1> Tells CDI that it should use this constructor to create an instance of `PostService`
<2> Tells CDI to use the `InMemoryConcurrentPostRepository` bean to call this constructor

===== Adding a qualifier on an injection point

Any number of qualifiers can be added on a CDI injection point. CDI will look for a bean that matches all the defined qualifiers. If no bean, or more than one bean matches the definition, then an error will be raised. Of course, this bean can have more qualifier than needed to be injected. The set of all the qualifiers a bean has has to be a subset of the needed qualifiers.

==== Existing qualifiers

CDI defines four qualifiers:

* `@Named`
* `@New`
* `@Default`
* `@Any`


===== The `@Named` qualifier

This qualifier has a special status, as giving a name to a bean is mandatory for certain categories of beans in the Java EE world. But we can also give names to our beans outside of this context, just for the sake of the readability of our code.

This annotation defines a `value` attribute, which holds the name of the annotated bean.

===== The `@New` qualifier

This qualifier was defined in CDI 1.0, and deprecated in CDI 1.1. So you should not use it in your code, apart from using it for legacy reasons. We are not going to cover this annotation in details. Instead of injecting `@New` beans, you should inject `@Dependent` beans.

The `@New` annotation can take a default attribute which type is a class. This class is the one to instantiate to inject the annotated bean. If the value attribute is not specified, then the class of the bean will be instantiated.

===== The `@Default` qualifier

CDI adds the `@Default` qualifier on all the beans that have no qualifier. There is an exception for the `@Named` qualifier: a bean that has this qualifier will get the `@Default` qualifier also. So any producer that has no qualifier, or that has the `@Named` qualifier as its only qualifier, has this `@Default` qualifier.

Adding this qualifier explicitly is perfectly legal from a pure technical point of view, but would not make a lot of sense: let CDI handle this qualifier for you.

The same goes for the injection point. CDI adds the `@Default` qualifier on any injection point that defines no qualifier. The use of the `@Named` qualifier on injection points is not recommended. The `@Named` qualifier implies string-based bean identification, and this approach is not the recommended one any more.


===== The `@Any` qualifier

The `@Any` qualifier is present on all the beans CDI can handle, except for the `@New` beans that you should not use in your application. So one could think that this qualifier is useless, since it is present everywhere. It has in fact a very precise use, that we will see later, when we talk about programatic lookup.

The fact that this qualifier is present on all producers explains the error message we saw when we created ambiguous injection points and producers.

==== Injection by identifier vs injecting by type

So at this point, we have two ways of producing and injection beans. The first one relies on the Java type system. It works very well, leads to very simple and clean code, as well as robust patterns. But as we saw, most of the time it is not precise enough, since we may want to produce several beans of different kinds, but with the same type. We saw the example of the `EntityManager`, and there are many other. Many configuration parameters of our applications are injected in various places, and they are all `String`, `int`, or other very general Java types.

So CDI introduces the notion of _qualifier_ to add precision on the Java type of a bean. A qualifier is a just a simple annotation, that we can add both on the producing side, and on the injection side.

The full CDI Bean Type is thus the combination of the Java types (classes and interfaces) of a given bean, and its qualifiers.

In some cases, we might want to not take into account all the Java type hierarchy. For instance, we might want to add to the CDI Bean Type, only the interfaces, and not the implementing class, not the `Object` class. And even for the interfaces, some of them do not carry an relevant information for our CDI application. It might be the case for `Serializable` or `Cloneable`.

The question is: can we remove some Java types that a bean has from the CDI Bean Type? It turns out that the answer is yes. We can add an annotation on the production side that we tell CDI what Java types to take into account when building the CDI Bean Type. This annotation is simply `@Typed`, and it gives the list of those Java type. Let us go back to our `InMemoryConcurrentPostRepository` example, and let us add the `Serializable` interface to its declaration.

[[app_listing]]
.The CDI Bean Type of the `InMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

How does CDI build the CDI Bean Type of this bean?

First, this class does not have any qualifier, so CDI automatically adds the `@Any` and `@Default` qualifiers to it. If we had added an explicit qualifier, then the `@Default` qualifier would not have been there.

Then CDI adds the Java types: `InMemoryConcurrentPostRepository` of course, but also `Object`, as it is the case for all the beans. Then it also adds the two declared interfaces: `PostRepository` and `Serializable`.

Now the question is: do we really need the `Object` type and the `Serializable` Java types? They are so general, that they do not carry much information. Having general types in our CDI Bean Type set might lead to weird errors in our applications. Suppose we forget to add a dependant JAR for instance, with some important producers in it. The error we might get is that there are too many beans with the type `Object` to inject at a given injection point. What we would like to have is an error stating that this injection point has no matching bean to inject.

So we may add the `@Typed` annotation to the definition of our bean.

[[app_listing]]
.The CDI Bean Type of the `InMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

@Typed(PostRepository.class)
public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

This time, the only Java type we have in the CDI Bean Type is `PostRepository`, and this is what we expect.

So the `@Typed`annotation, is another annotation we have in our toolbox to select which Java type CDI gives to a bean, among the available Java types a bean has.


=== Advanced concepts in qualifying bean

There are two concepts we need to go through on the topic of the CDI Bean Type system. Those two concepts are `@Alternative` and `@Specializes`. These concepts are quite complex, but in some vey precise cases, needed in CDI applications.

==== Introduction

Suppose we have a working CDI application with many producers and injection points. Everything was very carefully designed and written, and the application heavily relies on qualifiers to associate producers and injection points.

And for some reason, testing, debugging, you name it, we need to substitute a bean with another bean. We want to provide a class that should be used by CDI to create a given bean, wherever this bean is used in our application. This can be a real nightmare to do, especially if our application is large an complex.

The solution cannot rely on adding some kind of information (qualifier for instance) on the injection points. First it would be very error prone (suppose we forget one). And it would also be very complex. This would not lead to a reliable solution, also due to the fact that an application can get an instance of a bean by programmatic lookup, a point that we have not seen yet.

So the only reliable way to do that is to act on the producing side. An approach one could think of could be to create a class with the exact same Java types. The simplest way to do that is to extend the class we want to substitute and the same qualifiers to it. But by doing that, we would create an ambiguity in our CDI application, since we would define two beans with the same CDI Bean Type. We cannot add a special qualifier to it, since we would then need to add this qualifier everywhere on the injection side, a solution that we discarded.

This is exactly for this kind of situation that the `@Alternative` concept has been created in CDI. The bean we want to substitute to the normal, injected bean, is declared as the _alternative_ of the normal bean, and then, CDI will magically inject this alternative in place of the normal bean.

==== Creating an `@Alternative` bean

From a technical point of view, creating an alternative bean is really simple. We just need to add the `@Alternative` annotation where the bean is produced and we are done.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class as an alternative using an annotation
[source,java]
----
package chap04.repository;

import javax.enterprise.inject.Alternative;

@Alternative
public class InMemoryConcurrentPostRepository implements PostRepository, Serializable {

    // content of the class
}
----

===== Annotation versus XML declaration

Adding an annotation is very simple, but it requires the compilation of the class where we added the annotation. We must consider two cases here.

The first one is the case where this alternative class is a separate class, created for this case. Adding this annotation to this class is the natural way of doing it. If this class is a test class, it will not be deployed at runtime. If this class is some temporary class that we need to add to our application for debugging or auditing purposes, then we can put it in a separate JAR and remove that JAR when we do not need it anymore. In both cases, we do not need to recompile all our application to declare this alternative.

The second case is a bit more complex. We want a class that is already in our application to become the alternative. If we decide to add this annotation to it, then we will need to recompile everything, a step that might be costly, too costly for our needs.

We might come across this kind of situation quite often in Java EE applications. Another famous example is the declaration of named queries in JPA modules. You have two ways to do that: the first one is to add them using annotations, thus requiring to rebuild your application.

Instead of doing it that way, we can also add the declaration of alternatives in the `beans.xml` file. Using this way, we do not need to recompile our application, we only need to redeploy it with the modified `beans.xml`file. It is good to keep in mind this way of modifying the configuration of Java EE elements, since it may prove much more efficient than having to recompile and rebuild everything.

Declaring an alternative in the `beans.xml` configuration file is really easy. Let us see the following example.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class as an alternative in the `beans.xml`configuration file
[source,xml]
----
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                           http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd">

   <alternatives>
      <class>chap04.repository.InMemoryConcurrentPostRepository</class>
   </alternatives>
</beans>
----

===== More than one bean annotated with `@Alternative`

It is possible to have more than one bean with the same CDI Bean Types annotated with `@Alternative`. Of course this case will raise errors due to ambiguities in the resolution of which of those beans should be used to injection. In this case, one of these classes has to be referenced in the `beans.xml` file to resolve the ambiguity.

===== Selecting an alternative bean with the `@Priority` annotation

There is still another way to choose from several beans annotated with `@Alternative`. This way consists in adding a `@Priority` annotation along with the `@Alternative` annotation. This annotation will make this bean the chosen one among the other alternatives. The `@Priority` annotation takes an `int` attribute that has no default value. So we must give a value to this priority. The exact meaning of this attribute is left to the specifications that use them. CDI does indeed mention it for alternatives, but does not give precision on the way this attribute is used. So far we assume that only one alternative can be annotated with `@Priority`.


===== Alternative use cases

Alternatives are a very powerful tool that can be used in several use cases.

The first one of course is when we need to inject of mock object to test a special class. Declaring our mock class as an alternative makes it very easy to inject this mock object instead of the runtime bean. The mocked class is only known in the test context, and will not be deployed at runtime (if it is the case, fix it!). So all we need to do if to extend the class of the real bean, sparkle some mocking magic on it, put the same qualifiers on this class, and add declare it as an alternative, either by annotating it, or by declaring it in the `beans.xml` file.

But we can also imagine other use cases. Suppose our application is internationalized. We could imagine having a bunch of supported locales, each represented by sets of classes, put in different packages. These classes are in fact models for CDI beans, and are meant to be injected, or are referenced by JSF templates. One way of organizing this is to set the correct set of class as the alternative in a given deployment scenario using a given locale. 

==== Creating a `@Specializes` bean

Unfortunately, there are still cases where alternatives are not enough to override a given bean definition.

Remember that an alternative is selected as a bean only if both CDI Bean Type are the same. Let us consider the following example.

We are still dealing with our in-memory `PostRepository`. So we have this interface `PostRepository`, and two implementing classes, `InMemoryPostRepository` and `InMemoryConcurrentPostRepository`. We learned about qualifiers and decided to further explain the difference between those two implementations by putting a `@Concurrent` annotation on the `InMemoryConcurrentPostRepository` implementation.

So the declaration of these two classes is the following.

[[app_listing]]
.Declaring the `InMemoryConcurrentPostRepository` class with the `@Concurrent` qualifier
[source,java]
----
package chap04.repository;

@Concurrent
public class InMemoryConcurrentPostRepository implements PostRepository {

    // content of the class
}
----

[[app_listing]]
.Declaring the `InMemoryPostRepository` class
[source,java]
----
package chap04.repository;

public class InMemoryPostRepository implements PostRepository {

    // content of the class
}
----

Now, for testing purposes, we decide to extend the `InMemoryConcurrentPostRepository` class with a mocking class: `MockInMemoryConcurrentPostRepository`. The definition of this last class is the following.

[[app_listing]]
.Declaring the `MockInMemoryConcurrentPostRepository` class
[source,java]
----
package chap04.repository;

public class MockInMemoryConcurrentPostRepository extends InMemoryConcurrentPostRepository {

    // content of the class
}
----

This is our setup for the definition of the beans we are going to use.

Of course, we have different injection points for these post repositories in our application. Let us see a first one, that just needs a `PostRepository`.

[[app_listing]]
.Declaring an injection point for a post repository
[source,java]
----
@Inject
private PostRepository repository;
----

What is going to happen with our setup? Well, CDI will first register the beans that can be injected in this field. It will find 3 of them: `InMemoryPostRepository`, `InMemoryConcurrentPostRepository` and `MockInMemoryConcurrentPostRepository`. And since it has no information to tell which implementation should be used, an error will be raised. We need to fix our code.

Thanks to our hard work in trying to learn CDI, we know that we have this `@Alternative` annotation that we can add on a type to resolve ambiguities. This is what we do: we add the `@Alternative` annotation on the declaration of `MockInMemoryConcurrentPostRepository`. And indeed it fixes the ambiguity, our testing code is running smoothly.

But then we realize that when this mocking class is not there anymore, the ambiguity is still there: CDI cannot tell from `InMemoryRepository` and `InMemoryConcurrentRepository`. Basically our test was running smoothly, but in production it did not work, due to the fact that this alternative is not there anymore.

We then to resolve this ambiguity again. We could use `@Alternative` agin, bu we prefer to add the `@Concurrent` annotation, since this is what our code needs. This approach is the best one, since is makes our code more readable. This time, our injection point looks like the following.

[[app_listing]]
.Declaring an injection point for a concurrent post repository
[source,java]
----
@Inject @Concurrent
private PostRepository repository;
----

Indeed, this annotation fixes our code in production, since the injected bean has to have the `@Concurrent` qualifier.

And then we realize that our test code does not work anymore! The `MockInMemoryConcurrentPostRepository` is not injected; the test code still injects the`InMemoryConcurrentPostRepository`. Why so? Simply because the qualifiers are not inherited. The `MockInMemoryConcurrentPostRepository` does not have the qualifier `@Concurrent` and thus is not a candidate for injection here. This will probably not look natural for many people. What are we doing here? We extend a class, add the `@Alternative` annotation on it thinking that it will fully override the class we extend, and in fact it does not, because the annotations are not inherited.

Most of the time this is not what we want. This is precisely to overcome this problem that the specialization has been added to CDI. In a nutshell, adding the `@Specializes` annotation to the overriding class will do the trick: CDI will take it in place of the overridden class, wherever this class is used.

When a bean _specializes_ another bean then we are sure that this other bean is not used as a bean by CDI. It is not seen, not instantiated, nothing.

For a bean to be a specialization of another bean, either its class must directly extends the class of this other bean, either its producing method must directly override the producing method of the first bean. Then the `@Specializes` annotation must be added to the class or to the producing method, as the case may be. Note that it the producer is in fact a field, no specialization can be set up, since a field cannot be overridden.

This specialization has a side effect, which is probably the desired effect in most cases. If the original bean declares itself one or several producing methods, or observers, those will not be seen by CDI, and thus not activated. Once again, this is probably what we want, since specialization will be used, most of the time, in a testing environment.

=== Getting more flexibility with Programmatic lookup

* @Any
* Instance<T>
* AnnotationLiteral, TypeLiteral

=== Using @Stereotype to simplify @Alternative
=== Wrap-up

