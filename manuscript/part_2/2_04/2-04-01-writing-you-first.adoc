=== Writing your first, minimal CDI application

Let us first write a first and very simple CDI application. In this example, we are going to use CDI concepts that we have not defined yet. But seeing them in action will give us a first glimpse at what they are, and how they work together. In a second part, we will describe all those concepts in full details.

==== Bootstrapping Weld

As we already explained, a CDI application needs a container to work. This container is in fact an implementation of CDI. Weld is the reference implementation for CDI. This container is production ready, and used in supported application servers.

To use Weld in a Java SE environment we need to add the following dependencies to our Maven project.

[[app-listing]]
.Maven dependency to bootstrap Weld 2
[source,xml]
----
<dependency>
    <groupId>org.jboss.weld.se</groupId>
    <artifactId>weld-se</artifactId>
    <version>2.2.15.Final</version>
</dependency>
----


// TODO: fix the version of Weld
The version used here is the 2.2.15.Final, which is the current version as of the writing of this book. Weld V2 supports CDI 1.2.

Bootstraping Weld is done by using the following pattern. We have written it in a `main` method for the sake of simplicity.

[[app_listing]]
.A minimal code to bootstrap Weld 2
[source,java]
----
package chap04;

import org.jboss.weld.environment.se.Weld;
import org.jboss.weld.environment.se.WeldContainer;

public class BootstrapingWeld {

    public static void main(String... args) {

        Weld weld = new Weld();
        WeldContainer container = weld.initialize();

        weld.shutdown();
    }
}
----

This code is really very basic and very easy to understand. Weld is just a container. To start it up, we just create a `Weld` object, and call the `initialize()` method on it. At the end of our application, we should call the `shutdown()` method for Weld to clean up its used resources. In this example, this call is not really needed, since the JVM will be shutdown at the end of our `main` method anyway.

Of course this code does not do much. It basically creates the Weld container, and shuts it down.

But it is still interesting, because what we get if we run it is an error message. Weld is complaining for not finding a needed file: the `beans.xml` file. This file is in fact needed to define a _bean archive_. This _bean archive_ concept is a CDI concept, that we will define in the next part. A bean archive is linked to the presence or the absence of this `beans.xml` file. So the simple fact that this file is there has its importance in the CDI context. Now this file also declares elements that are used by CDI to initialize our application. Basically, this files contains information, that we call _metadata_, used to create our CDI application.

==== Adding a `beans.xml`file

So let us add the following `beans.xml` file to our application.

[[app-listing]]
[source,xml]
----
.A first `beans.xml`file
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                           http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd">

       version="1.2"
       bean-discovery-mode="all"
</beans>
----

It is indeed a very classical XML file. The namespace is `http://xmlns.jcp.org/xml/ns/javaee` and the schema location is `http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd`. The root element of this XML document is `beans`, and this element is empty. So we can see that this file does not define anything.

Where should we put this file? In the `META-INF` directory of our application. We just need to be careful here if we are using Maven. In that case, the place to put the `beans.xml` file is `src/main/resources/META-INF`. It we put it in `src/main/java/META-INF` it will work also, but Maven will not package our application correctly, and the `beans.xml`file will not be added correctly to the JAR.

Running our application again now works, and does not do anything, which the expected behavior. So now that we have a correctly configured application, let us add now some classes and interfaces to actually do something.

==== Adding some content to our application

We used a simple example in the first part of this book. It was about posting messages to a repository. We used two classes: `PostService` and `PostRepository`. Let us take a simplified version of this very basic application.

We have three very simple Java elements: one class and two interfaces.

The first class is the `Post` class, used as a payload in our system. We removed the `User` class, for the sake of simplicity. You can add a `toString()` method to this `Post` class if you want to trace things in the example code.

[[app_listing]]
.The `Post` class
[source,java]
----
package chap04.model;

public class Post {
}
----

The we have a `PostService` interface, that defines what we can do with posts. Our system is still very simple, we can only save posts in a repository.

[[app_listing]]
.The `PostService` interface
[source,java]
----
package chap04.service;

import chap04.model.Post;

public interface PostService {

    public void post(Post post);
}
----

And then we need to define a `PostRepository` interface, to save our posts in some kind a persistent backend. It could be a XML repository, a relational database, a NoSQL database, whatever.


[[app_listing]]
.The `RepositoryService` interface
[source,java]
----
package chap04.repository;

import chap04.model.Post;

public interface PostRepository {

    public void save(Post post);
}
----

Now we have a well-designed system that compiles properly. Of course, if we want it to save posts, we will need to provide implementations for our interfaces.

The implementation of the `PostService` interface relies on the `PostRepository` interface.

[[app_listing]]
.The `PostServiceImpl` interface
[source,java]
----
package chap04.service;

import chap04.model.Post;
import chap04.repository.PostRepository;

import javax.inject.Inject;

public class PostServiceImpl implements PostService {

    @Inject
    private PostRepository postRepository;

    @Override
    public void post(Post post) {
        postRepository.save(post);
    }
}
----

What is this `@Inject` annotation? Well, it is the first trace of the CDI magic we talked about earlier. It tells the CDI container (which is in fact a Weld container in this example): find a concrete class for the `PostRepository`, instantiate it, and when I call the `post()` method, I want that instance in the `postRepository` field. This is called dependency injection, CDI is quite good at that.

CDI is very smart, but there are things it cannot do. It cannot build a concrete implementation of `PostRepository` on its own, so we need to provide one. Here we go. First, let us write a simple in memory implementation of our `PostRepository` interface.

[[app_listing]]
.The `InMemoryPostRepository` class
[source,java]
----
package chap04.repository;

import chap04.model.Post;

import java.util.HashMap;
import java.util.Map;

public class InMemoryPostRepository implements PostRepository {

    private long id = 0L;
    private Map<Long, Post> posts = new HashMap<>();

    @Override
    public void save(Post post) {
        long id = this.id++;
        posts.put(id, post);
    }
}
----

This implementation will do the job in very simple cases. It is not concurrent aware, so we should not call this class from multiple threads. If we do, we will certainly lose posts, and most probably corrupt our repository. So do not use such a naive implementation in production! But for our first, simple example, it will be enough. Once again, you can add a `toString()` method if you want to trace things precisely.

Be careful that CDI needs to be able to instantiate a class using the Java reflection API. We need to keep that in mind, and build implementation classes with empty constructors. Remember that the empty constructor is there only if there is no constructor defined in a class. If we add a non-empty constructor, then we need to also add the empty constructor explicitly if we want it to be there.

In fact, there are cases where CDI can use another constructor than the empty one. We will see this technique later.

Notice that our system is designed with interfaces and does not use classes directly. This is a good practice. It you are aware of the SOLID design principle, programming against interfaces follows the L principle, that is the Liskov substitution principle.

==== Running our first CDI application

At this point, we have a very simple, but fully working CDI application. Let us write the code to run it.

[[app_listing]]
.The `Main` class
[source,java]
----
package chap04;

import chap04.model.Post;
import chap04.repository.PostRepository;
import chap04.service.PostService;
import org.jboss.weld.environment.se.Weld;
import org.jboss.weld.environment.se.WeldContainer;

public class BootstrapingWeld {

    public static void main(String... args) {

        Weld weld = new Weld();
        WeldContainer container = weld.initialize();

        PostRepository repository =
            container.instance().select(PostRepository.class).get(); // <1>
        PostService postService =
            container.instance().select(PostService.class).get();

        postService.post(new Post()); // <2>

        weld.shutdown();
    }
}
----
<1> this is the pattern to get an instance of a CDI bean
<2> the CDI magic is at work behind this line of code: no null pointer exception, the post is correctly saved

This example does in fact two things, apart from bootstraping and shutting down the CDI container.

It first get instances of the `PostRepository` and the `PostService` interfaces. The pattern to do that might look a little complex, with three chained method calls. It is in fact a Weld pattern, not a CDI one. Note that the objects returned are fully initialized: The instance of the `PostService` interface returned is built no the `PostServiceImpl` class, and has been injected with a `PostRepository` instance.

What are the classes of the instances of `PostRepository` and `PostService` provided by Weld? We could expect the answer to be `InMemoryPostRepository` and `PostRepositoryImpl`. In fact it is not the case. For some reason, Weld (and all the other implementations of CDI) builds its own implementing classes. Of course these implementations are based on the one we provide, but they are still not the same. There are good reasons for Weld to work like that, we will see some of them later. It is good to have that in mind when designing CDI applications.

This example will work if the attribute `bean-discovery-mode` of the `beans` XML element of our `beans.xml` file has been properly set to `all` If it is not the case, or this attribute is not present, then we will get errors running this example.

==== Wraping up our first example

In a nutshell, we built the following:

* a `META-INF\beans.xml` file, that defined a _bean archive_;
* set of interfaces and implementing classes, tha defined _bean_ in the CDI sense;
* a running example with some explicit Weld calls.

Let us browse through all what CDI did for us.

* It could scan our classpath, and associated the implementations of `PostService` and `PostRepository` to their own interfaces.
* When we asked for an implementation of those interfaces, it was able to create one, without any help from us.
* It was able to set the annotated field with an instance of the right interface, once again, without any help from us.
* When we ran our example, it just worked as expected.

All these with a vey minimal configuration.
