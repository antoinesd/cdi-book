nvet:chapter: 1
:sectnums:
:figure-caption: Figure {chapter}.
:listing-caption: Listing {chapter}.
:table-caption: Table {chapter}.
:sectnumoffset: 0
include::../header.adoc[]

[[chap01-introduction-to-cdi]]

////
I inserted what I think is the correct set of declarations at the top of your file. I also adjusted your heading levels. Consult with Ben Berg for help. Also, I highly recommend a tool called AsciiDocFX (http://asciidocfx.com/); it has a built-in preview pane and you can easily generate PDFs with it. --MM
////

= Introduction to CDI


////
In addition to editing this chapter as though I am seeing it for the first time, I am copyediting this chapter for ESL issues. So you'll see some changes in punctuation, grammar, and spelling. If you want to see the individual changes in this file, instead of just seeing which lines have changed, I hear that IntelliJ has a very nice Diff tool you can use for that purpose (https://www.jetbrains.com/idea/help/running-intellij-idea-as-a-diff-or-merge-command-line-tool.html).

Overall chapter comments:

1. Each section and subsection needs an introduction that tells your readers what you are teaching in that section and why you are teaching it.

2. Revise this chapter so that you provide a clear mental model of what CDI is and what it does. This means rearranging some of the material. I didn't copyedit the sections I am asking you to revise heavily, and I also didn't comment on those sections in depth.

3. Rewrite several sections so they teach their topics starting with concrete information and moving to abstract information. Use graphics. See my notes under "Dependency injection."

4. I commented on a few sections that I think could be moved to an appendix.

5. Make sure that all your headings tell a complete story. If the heading were taken out of context, would readers have a good idea of what you are teaching? If not add more to the headings to make it clear.

--MM
////

.This chapter covers
****
* defining CDI and its core concepts, like dependency injection or Contexts management
* listing some of the problems that CDI solves
* defining the CDI role as a Java EE specification and its consequences
* websites where you can get more resources on CDI
* a discussion of the main alternatives to CDI

////
In the first bullet, should it be "context" rather than "contexts"?

I rewrote the fourth bullet, but really resource material should go into an appendix. --MM
////
****

One of the strengths of the Java world is the vibrant open source community that it's gathered in the last two decades.
This community has developed countless wonderful tools, frameworks, and APIs.
Some of those have been integrated into the JDK itself, while others have become _de facto_ standards.

Some of those standards were integrated in the Java Enterprise Edition platform (Java EE), both as a specification and a reference implementation.
This is the case for Context and Dependency Injection (CDI).
The CDI specification was first brought to the Java EE platform as a tool to glue together web page templates and middleware Java code.

////
1: Move the following material (through to my comment labeled 2) into a separate section in this chapter. It doesn't belong in this introduction. That separate section is an overview of the book. --MM
////
Through this book, we give you precise information about the technical possibilities brought to you by CDI: what CDI can do for you, and what the corner cases are.
CDI has been designed with certain ideas in mind, and it is important for you, as an application architect or a developer, to know how to use CDI correctly.
This is the first step.
After that, we describe precisely how you should use CDI, and what patterns you should follow to build CDI applications.
We provide many examples of code, patterns, and snippets that you can easily reuse in the context of your own applications.

The first part of this book gives you a quick overview of what CDI can bring to you and your applications.
It browses all the most important ideas, without going too deeply to the technical details.
We give lots of examples and code samples.
The goal of those examples is twofold: first, answering the first questions you may have in mind, with simple answers and examples.
Second, those examples show you how to set up a working environment that we will use through all this book.
Setting up an environment means choosing an implementation.
The implementation we choose is Weld, the reference one.
////
After the sentence,"Setting up an environment means choosing an implementation," add another sentence in which you explain what an "implmentation" is. --MM
////

The second part is a deep dive into all the concepts of CDI.
Obviously, for the sake of simplicity, the first part will leave some questions unanswered, and some corner cases unexplained.
CDI brings many concepts to the Java EE platform, and in this part, we are describe them all one by one.
This part might look tedious, just because CDI is a very rich framework, with many interesting things built in it.

The third part describes the most advanced features of CDI: deployment, Service Provider Interface (SPI), and extensions.
Not all applications developers will need a good understanding of every aspect we describe in this part, but it is still worth reading: many gems are hidden here! CDI can do a lot for you, possibly much more than you think.
You can use the extension system very efficiently to build new features that your application needs.
In this part we will talk about several projects, especially Deltaspike, which became Duke’s Choice Award winner in 2014.
The Duke's Choice Awards celebrate extreme innovation in the world of Java technology and are granted to the most innovative projects using the Java platform.

The last part is about integrating CDI in your own environment and having it interact with your existing applications.
Despite the fact that CDI is quite new in the Java platform, and especially in the Java EE world, you can integrate it in your legacy code.
With CDI 2.0, you do not need a Java EE application to use CDI: you can integrate it with Java SE.
This opens the door to many opportunities.
Of course, not everything is available in the SE version of CDI, but you can still use many powerful features.

In fact, integrating CDI in a legacy application can be a very efficient way to clean up your code, to decouple your old modules into CDI elements.
It will help you make your code testable, which is one of the greatest problems when one deals with legacy.
////
@: From my comment labeled 1 to this comment, move this material to an "overview of this book" section later in this chapter. --MM
////

////
Now add more to this introduction so that it is an overview of the chapter, not the book. --MM
////

== What is CDI?

The CDI acronym itself (Context and Dependency Injection) is built on two main ideas,
the first being dependency injection, and the second being the notion of context.
Let us quickly describe those two notions.

////
In the paragraph above, give more of an overview of what you are teaching in this section. Include a brief definition of CDI--what it is, not what it does.--MM
////

=== CDI in a nutshell
////
Add some graphics to this section to illustrate the processes you are teaching.

Also, this section does not provide a clear idea of what CDI is and what it does. See my note 5 (later) about teaching topics by going from concrete to abstract. You need to add a mental model with graphics. You have some good material in the section, "The CDI container," that you could move to here. Let's discuss when we meet. --MM
////

////
3 Remove this material from this point to comment 4. --MM
////
How do new ideas take shape in the Java space? The process is nearly always the same. As soon as new ideas emerge, some open source implementation is produced.
This implementation is watched by the community, some more contributors show up, bringing new ideas and improvements.
Other implementations may be built, taking into account the good ideas and the drawbacks of the previous ones.
This Darwinist-like process of selection and rejection is just how open source works and brings more and more innovations every day.

This community also used the Java platform as a basis to demonstrate new concepts in software development.
From the first books describing design patterns to the articles and blog posts about clean code and best practices, the _sofware craftsmanship_ movement has shown many patterns and developed many _katas_ in Java.

// Define katas above. --MM

// 4 --MM

CDI is at the intersection of two flows of ideas. The first one comes from the needs of a better integration between the middleware layer and the presentation layer.
Allowing the reference of model beans in the presentation layer (namely in JSPs) just by naming them and letting the framework do the complex wiring was a great step forward in writing simpler and cleaner presentation components.

////
In the paragraph above, who or what is doing the allowing? The CDI specification? Dependency injection?
////

The second flow is the development of patterns of code based on __dependency injection__.
We will talk more about dependency injection, since this is at the heart of CDI.
This idea is clearly not new, but it took a while to shape it as it is now.
CDI itself was not built from the ground as a standalone dependency injection framework.
Its evolution took time and effort.
It is now a very mature specification, with, as you will see, several high-quality implementations.

////
Right after the first sentence in the paragraph above, briefly define dependency injection.

Also, tell your readers where you will talk about dependency injection (such as by saying "later in this book" or "in chapter X").

--MM
////

The Java platform itself relies on the ideas that are the foundation of Open source.
As developed through a JSR, or Java Specification Request, part of the JCP, or the Java Community Process, CDI is one of the many specifications born on this open process.
Such as many specifications, CDI is the result of a joint effort of many people and companies, that decided to bring their forces together to define the notion of Context and Dependency Injection for the Java EE platform.

////

////
CDI is certainly not perfect, but keeps improving release after release, thanks to the constant efforts and contributions of the community.
The book you have in your hands would not exist without this work.
Everyone can contribute at different levels: from providing feedback to fixing a bug or submitting a new feature.
So if you feel like it, just go ahead: you can easily contribute on http://cdi-spec.org/.

As a standardization effort, CDI is built on ideas that are not necessarily new, ideas that many developers (and readers) already know.
So why is it worth writing a book to tell developers things they already know?

Because, as a joint effort, CDI puts together things in a certain way, and enables certain patterns of development.
CDI opens many new opportunities in the way we design modern business applications, from small projects to largest ones.
There are good ways of using CDI, to fully leverage all its power, good practices, and this is what this book is about.

You may think that the reference implementation of a given Java EE specification might be a working one, but certainly not the one to use in a real production environment.
This idea is really dated to say the least.
From Java EE 5, the paradigm of building a specification from the ground up, and then trying hard to build an implementation, just to discover that the specification is wrong is gone.
From Java EE 5, specifications are built on improved ideas, strong enough to make it in the Java EE platform.
This has been the case for JPA, built on top of Hibernate and EclipseLink, and it is also the case for CDI.
So yes, the CDI reference implementation: Weld, can definitely be used in real production environment, and this is already the case.


=== Dependency injection
////
Manning style: Chapter titles and headings use sentence case. That means the only words that get capitilized are the first word in the title/heading, and any proper nouns. --MM
////

////
5: Teach dependency injection using the "diagram first" approach. We'll discuss this when we next meet. Briefly, "diagram first" means to teach a topic using the following techniques in the following order. These techniques are quite effective in helping your readers learn what you are teaching more easily.

1. Go from concrete to abstract. Start with a scenario, something like, "Say you have problem X. Dependency injection (define briefly) solves that problem."
2. Include a graphic of the problem and its solution. Before the graphic, discuss the graphic a bit. In the graphic and its caption, include enough information that, if the graphic were taken out of context, your readers will still know what you are teaching.
3. Discuss the problem a bit further and include more graphics as needed, breaking it down into logical pieces.
4. If what you are teaching includes some code, show the _output_ of the code, with some discussion.
5. Show the code. Annotate the code if it needs it. If the code is really long, break it up into segments and discuss each segment one at a time.
6. Reiterate the diagrams, discussion, and code until you have taught the topic.
7. Include some simple, quickly done exercises (drap and drop code, multiple choice, etc.; I'll send you guidelines for exercises.).
8. Finally, conclude with some generalizations about the topic.

Because I am asking you to revise this section pretty heavily, I am not going to copyedit or edit any more of this section. I'll start again at "Context."

--MM
////
Let us first explain what dependency injection is.
And let us begin by explaining where this idea comes from.
Dependency injection is in fact not a new idea.
It comes from the notion of _Inversion of Control_.
The idea of inversion of control was first expressed as the _Hollywood principle_: you don't call us, we call you. What does that mean?
The explanation is give in the popular book _Design Patterns: Elements of Reusable Object-Oriented Software_, by Erich Gamma, Richard Helm, Ralph Johnson and John Vissides (Addison-Wesley, 1994).

In the chapter _Template Method pattern_, we can read:

[quote]
The Hollywood Principle refers to how a parent class calls the operations of a subclass and not the other way round.

The Template Method pattern is very widely used. We can see many examples of it in the JDK itself.
For instance, the `HashMap` class extends the `AbstractMap` class.
The `AbstractMap` has an abstract method `entrySet()`, that is called by its concrete method `clear()`.

.The Hollywood principle parent class: example of the JDK `AbstractMap` class
[source]
----
public abstract class AbstractMap {
    public abstract Set<Entry<K,V>> entrySet();

    public void clear() {
        entrySet().clear();
    }
}
----


.The Hollywood principle child class: example of the the JDK `HashMap` class
[source]
----
public class HashMap {
  public Set<Map.Entry<K,V>> entrySet() {
    Set<Map.Entry<K,V>> es;
    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
  }
}
----

The idea behind this pattern is that one can build algorithms (very simple ones in this example), that rely on code that is not written yet.
We know that at runtime, we will have an implementation of this abstract method `entrySet()`, so it is correct to use it.
From this example, we can see that the idea of inversion of control is a classical one, that has already been used from the very early days of the Java language.

The book by Erich Gamma _et ali_ gives credit to the _Hollywood Principle_ to an earlier article: _The Mesa Programming Environment_ by Richard E. Sweet, published in 1985. This article itself credits Donald C. Wallace for the invention of the expression, in a document internal to the Xerox Corporation: __Tajo Functional Specification, Version 6.0__, published in 1980.
Unfortunately this last reference seems not to be publicly available.
This idea of Inversion of Control is nothing new even outside of the Java space, dating back to the early age of programming.

In fact, several other patterns described in the book by Erich Gamma _et ali_ are seen as __inversion of control__. This is the case for:

* the factory pattern,
* the service locator pattern,
* the template method pattern (that we took as an example), and
* the strategy pattern.

Inversion of control is more general than dependency injection itself. Let us define now what dependency injection is.

We all know that accessing a resource through a global variable is definitely not something that you should do in your application.
This is a very old design principle.
If you call a method and pass parameters to it, and this method fetches some external dependency on its own, through a service locator for instance, then this method is lying to you.
You think it just depends on what you provide to it, and it does not: it gets some information from global variables or globally accessible services.
Most of the time, in this context, you will have trouble writing a unit test for this method.
You will end up writing complex code to mock this service locator, and if it is accessed in a static way, you will have a hard time doing that.

So what does make dependency injection so special?
The main difference with the Service Locator pattern for instance, is that it goes one step further in the Hollywood Principle.
Do not call me _at all_!
Dependency injection provides a very clean way to factor a dependency that is shared among all the methods of a class.

In the following example, the class `CustomerDAO` needs a reference on an `EntityManager`.
An `EntityManager` is the object from the Java Persistence API (JPA) that is used to access a database in a transactional way (do not rely too much on this quick and dirty explanation, an `EntityManager` is much more than that!).
Thanks to the `@Inject` annotation, every instance of `CustomerDAO` will receive a properly built `EntityManager` before the method `findById()` is called.
It is the responsibility of the Java EE container to create such an object, with all its dependencies properly built.

This is what dependency injection is: expressing some external dependency in the code, and let the container that runs my code resolves this dependency.

.`CustomerDAO` depending on a JPA `EntityManager`
[source]
----
public class CustomerDAO {
    @Inject
    private EntityManager entityManager;

    public Customer findById(Long id) {
        return entityManager.findById(Customer.class, id);
    }
}
----

Here we choose to express this dependency by annotating a field, CDI allows other ways to do that.
We will see all the technical details later in this book.

Without dependency injection (whether it is a CDI implementation or not), our `CustomerDAO` class would have probably used a service locator to get a reference to some kind of service, and then would have called the right method of that service to get the needed entity manager.
Basically, the `CustomerDAO` class would have carried some technical code to get the needed object.

To avoid this, another way would have been to write our `CustomerDAO` in this way.

.`CustomerDAO` without its `EntityManager`
[source]
----
public class CustomerDAO {

    public Customer findById(EntityManager em, Long id) {
        return entityManager.findById(Customer.class, id);
    }
}
----

All the methods of `CustomerDAO` that need this `EntityManager` have to declare it as a parameter.
It also means that the calling code has the responsibility to create this entity manager and to pass it to the methods of our DAO.
This leads to more complex code, since all the technical details of the creation of those entity managers will have to be present in our application code.

The process of changing the second version of our class (with the `em` as a parameter to all the method that needs it) to the first version
(with the injected `em`) is called __currying__.
Factoring common parameters in an injected field is a currying process, well known in functional programming.

As we can see it, using CDI leads to code that is simpler to read and to write.
Create a field, add the `@Inject` annotation to it, and this is all you need.
The framework will do the work for you. It is much easier to understand this code, and to maintain it in the long term.
This simple and basic pattern allows for better decoupling of the different modules of your application.
The dependencies are expressed in a simple way, without any technical details.

=== Context
////
Rewrite this section in the same way I've asked you to rewrite the section on dependencey injection, going from concrete to abstract and illustrating the concept with graphics. --MM
////

We spent some time describing the notion of dependency injection, because it is probably the most widely needed concept in an application.
Everybody has heard about dependency injection at some point.
All the details are not necessarily known and understood, but at least the general concept is.
////
Rewrite the last sentence above so you aren't making assumptions about your readers. --MM
////

The second main concept of CDI is the concept of __context__.
Let us spend some time to give a first explanation of this notion.

In fact, as for dependency injection, this notion is not a new one. Many of the applications we have been working on use the notion of context.
Let us see that on an example.

Our previous example, the `CustomerDAO` class is able to read and return customer instances from our database.
Our application can then use these objets, and maybe modifiy them.
Since those objects are bound to the database, these modifications should be made in the context of a database transaction.
The concept of transaction is certainly not a new one, every architect or developer knows this notion very well.

A transaction is an abstract notion.
It has a beginning, and an end.
At the end of a transaction, all the modifications are sent to the database.
If they are accepted, everything is fine, and we say that the transaction is committed.
But if they are not, then the modifications are rolled back, and so is the transaction.

Our customer objects are bound to a transaction.
They are created within a given transaction, and once this transaction is committed or rolled back, no one should touch them anymore.
This bound between them and the database does not exist anymore.
There is a trap here, because nothing in Java can prevent one from holding a reference to an object past the end of the transaction it is bound to.
But if my code tries to modify it past this boundary, it will most certainly raise a nasty exception.
This bound is in fact the transaction itself.

Let us go one step further, and abstract things a little.
This notion of transaction is in fact a context in the CDI sense.
This context has boundaries: a beginning and an end.
In the CDI sense, we call that a lifecycle.
This notion of lifecycle is very rich, and we can do many things with it.

The transactional context is special.
First it is probably among the most widely used.
Second at the end of a transaction, something special happens: it is either a commit or a rollback.

So a context has a lifecycle, which, in its most basic form, defines a beginning and an end.

We can bind objects to a context: our customer objects are bound to their transactions.
What does it mean to be bound to a context?
Simply said, it means that the bounded objects have a lifecycle too, which is the same as the lifecycle of the context they are bound to.

CDI brings abstractions for all these notions: contexts, lifecycles, binding of objects to contexts, etc...
They are of course specific contexts for the well known notions of transaction, HTTP request or HTTP session.
But we can also create our own contexts to suit the needs of our applications.

[[container]]
=== The CDI container
////
Move this material to under "CDI in a nutshell." When you do that, rewrite and expand this section using the same principles I discussed for teaching about dependency injection. Right now this section is too short and takes a lot for granted. --MM
////

Like most frameworks that add high-level services to standard Java classes, CDI uses a container to store all meta data and active components used in the current application.

The CDI container is the heart of the framework.
When running CDI in Java EE, this container is automatically provided to you by the Java EE server.
When running CDI in Java SE, you'll have to boot this container as we will see in <<java_se_boot>>.

////
What is that link above? Will it make sense in the printed version of this book?

In the first sentence below, what does "it" refer to? Give more context here--what is it, and why are you talking about it?
--MM
////

It contains all the beans defined in your application and all the bean instances (Java Object) that were previously created in active contexts so you can request them again.
It is also responsible to add powerful features to your components like eventing system, interceptor or decorator, among others.

But to have all the features provided by the container, you have to follow the CDI programming model you'll learn in this book.
For instance, you should never instantiate a bean class by yourself using `new` keyword.
To get the benefit of CDI you'll have to delegate all instantiation to the CDI container.
You'll discover other constraints for your code to stick to the CDI programming model.
By the way, it's why it is called a framework, because it enforces you to observe a collection of rules defining your frame of work.
These rules are more good practices and code standardization than real constraints as you'll discover in part 2.
////
Move your definition of framework to the first time you use the word "framework." Also, explain each of your sentences above. You are throwing out a lot of statements here without backing them up. You also do the same in the following paragraphs. --MM
////

Once the container is up and running, it is ready to serve you by providing you with the beans you will request.
But, strangely you'll discover that for most of the time, the container is invisible for you and that its "magic" is done automatically.

For instance if we write:

.Injection point "magic"
[source]
----
public class MyBean {

    @Inject //<1>
    MyService service;
}
----
<1> `@Inject` transform the field in an injection point

When `MyBean` is used for the first time, the container must provide a bean of class `MyService` at the injection point.
that means that the container looks for a bean having `MyService` in its type set.
When it found it, it checks if an instance of these bean already exist in active context.
If there are no instance, it creates it and, optionally, add it to an active context.
And finally it sets the `service` field with the instance it found or just created.


== Problems solved by CDI
////
Revise this section in the same way I discussed for dependency injection. --MM
////

Having a powerful tool is not enough to solve the problems architects and developers face when dealing with modern applications.
When the only tool you have is a hammer, all problems begin to resemble nails.
This proverb is not new and is perfect to illustrate this introduction.

CDI provides an easy way to inject dependencies in an application.
It also provides a very powerful implementation to create contexts both easy and portable.
Of course it does not mean that all the problems we face when building applications should be dealt with by using contexts and dependency injections.
Those two approaches are just patterns that can be applied to solve specific problems.
If a problem cannot be solved using dependency injection, then it could be harmful to bend it so that it fits the solution.

// TODO José: ajouter un graphique pour illustrer ça

////
Define your terms in the following paragraph. For example, what do you mean by saying that CDI follows a horizontal direction of development? A bertical direction of development? --MM
////

CDI follows two directions of development.
The first one is horizontal.
Beside dependency injection, CDI provides other functionalities: interception or decoration.
The second one is vertical.
On top of dependency injection, CDI introduces the notion of production (how can I build this specific object?) or typing (how can I distinguish an SSH key from the name of a directory when both of them are modeled by a `String`?).

The powerful container that implements the CDI specification (in fact there are several implementations of such a container) can be used for many more things than just contexts and dependency injection.
But the idea designers have in mind does not change: everything has to be kept simple and readable.
////
Who are the desingers in the sentence above? The peopel defining the CDI specification? Be explicit. --MM
////

How is it possible to make complex things simple? As we saw it on the first examples we showed, the syntax offered by CDI is kept extremely simple.
You want to inject a dependency in a field?
Just annotate it with the `@Inject` annotation, and you're done!

By default, CDI will look for a producer for that field.
To resolve that, it will check the type of that field, and see if it has a producer for that type.
How can I declare a producer? Easily: just annotate any kind of element that holds or returns an object of the right type with the `@Produces` annotation.


.A basic producer for an entity manager
[source]
----
@Stateless
public class EntityManagerProducer {

    @PersistentContext(unitName="MyJPAContext") //<1>
    @Produces //<2>
    private EntityManager entityManager;
}
----

<1> This is an annotation from the Enterprise Java Bean (EJB) specification. It creates an entity manager to inject if in this field.
<2> This is our CDI annotation, that tells CDI that this field can be used to get an entity manager.

In this very easy case, CDI sees that this field can be used as a producer of type `EntityManager`.
So it just wires that producer to all the injection points of the same type that we declared in our code.

This very powerful feature is called convention over configuration. CDI works with a set of general rules that are assumed to hold.
////
Why is it called convention over configuration? --MM
////
We can change these rules to better suit the needs of our applications, but most of the time, it is better to avoid doing this.

//= Code examples

//TODO: Is it still usefull with example in chapter 2 and the few examples we already gave above?

== The CDI specification

As we have said, CDI is a Java EE specification.

* CDI 1.0 was released as part of Java EE 6 in 2009.
* CDI 1.1 and its maintenance release CDI 1.2 were released as part of Java EE 7 specification in 2013 and 2014
* CDI 2.0 is part of the Java EE 8 specification and allows user to use it outside Java EE as well.

Being a specification and part of Java EE umbrella spec has consequences on the way CDI is designed and will evolve.
Let's go through this concept of specification to understand the impact on CDI.

=== The JCP
////
Do your readers need all this background information? Or are you including it because you think it is interesting? If the latter, move it to an appendix. If the former, make it clear at the start of this discussion what you are teaching here and why you are teaching it. --MM
////

In early Java days, Sun Microsystems, which owned Java at the time, decided to to create a community gathering all interested actors in the Java platform.
So they created the Java Community Process (JCP) to organize Java language and platform evolution.
Today, under Oracle government, the JCP pursues its work in specifying Java SE and the Java EE platform.
Here is how the JCP defines itself: 

[quote, JCP definition by JCP,https://www.jcp.org]
____
The JCP program holds the responsibility for the development of Java technology.
As an open, inclusive organization of active members and non-member public input, it primarily guides the development and approval of Java technical specifications.
Anyone can register and join the JCP and have a part in its process, and you don't even have to join to contribute as a public participant.
 
The work of the Java Community under the JCP program helps to ensure Java technology's standard of stability and cross-platform compatibility, enabling it to operate on hundreds of millions of devices, from desktop computers to consumer electronics to industrial robots.

(...) Anyone can sign up to become a JCP Member and then participate on the Expert Group of a JSR or even submit their own JSR [Java Specification Request] Proposals.
____

So, each specification in Java SE or EE have been proposed by someone (most of the time a company) through a JSR submission.

=== What is a JSR?

A JSR is a Java Specification Request. It's a small project to produce a specification document (and associated deliverable) which enhance the platform (Java SE or Java EE).
It's the core JCP tools to produce standard technologies for Java SE and Java EE.
To understand how it works and what it delivers, let's explore the details of a JSR. 

==== Lifecycle of a JSR
The JCP defines a very detailed lifecycle for JSR which is specified in a JCP process document (which is specified like any other JSR).

// Review the guidelines for including images. They are not showing up. --MM

[[jsr_lifecycle_fig]]
.Lifecycle of a JSR (jcp.org)
image::jsr_lifecycle.png[]

Without going in too many details, let's review the main steps of this lifecycle to better understand how CDI is designed.
A JSR is initiated by a company or an individual, by proposing a JSR proposal to the JCP.
The JSP acknowledge the proposal by giving it an ID number (e.g. JSR 365) to identify it during all its further life .
This proposal is then discussed among the JCP and then voted by JCP Executive Committee (elected individuals or company).

If the proposal is accepted it becomes a JSR and an Expert Group usually leaded by the individual or company representative who submitted the proposal. He becomes the specification leader of the proposal.
For some JSR, like for CDI, this role is held by more than one person.  

Any individual or company can apply to a JSR Expert Group (EG).
The specification leader is free to accept or refuse applications to form the EG.

Once the EG is formed, work on the spec can start.
During the spec writing, the EG may deliver one or more drafts of their work.
These early draft can be very useful for a broad spec like CDI to gather JCP and larger community feedback.

When the EG decide their work is over, they deliver a "proposed final draft".
This document is then subject to a approval vote by the EC.
If this ballot is favorable, the document is accepted as a new specification.

==== JSR Deliverable

A JSR should delivers the following artifacts:

* A specification document, which describes in details the rules and behaviour an implementation of the specification must observe.
* An API and its documentation to give a binary contract for the implementation and specification users.
* A Technology Compatibility Kit (TCK), which is a collection of binary tests that an implementation must pass to be conform to the specification
* A Reference Implementation (RI), bringing a proof of implementation for the specification
 
All these deliverable are the specification leader responsibility.
After the specification release (when the JSR is adopted by the EC), other third parties can create their own implementation of the specification and validate it with the TCK. 

=== CDI JSRs

Regarding the CDI, the specification already had 3 JSRs:

* JSR 299 specifying CDI 1.0, released in 2009 - https://www.jcp.org/en/jsr/detail?id=299
* JSR 346 specifying CDI 1.1 and 1.2, released in 2013 and 2014 - https://www.jcp.org/en/jsr/detail?id=346
* JSR 365 specifying CDI 2.0, released in 2016 - https://www.jcp.org/en/jsr/detail?id=365

All of these specifications have a dependency on *Dependency Injection for Java* specification (JSR 330).
This very light specification define basic annotations and interfaces for dependency injection.
Most alternatives frameworks to CDI described in <<alternatives>> also implement this specification making easier to create basic code working for all dependency injection solutions.


[[implementations]]
== The CDI implementations
////
Give more of an introduction to this section. Give your readers a clear idea of what you are teaching and why you are teaching it. --MM
////

Specification is nothing without good implementations.
CDI is lucky here with two excellent implementations: JBoss Weld and Apache OpenWebBeans.
For CDI 1.0 there's also a third implementation: Caucho CanDI

[[intro_weld]]
=== JBoss Weld

JBoss Weld is the CDI reference implementation (RI).
It is developed by Red Hat as an open source project under Apache License.
Weld provides a very powerful and well documented SPI and API to extend and integrate Weld in your own stack or application server.

The Weld documentation is very exhaustive showing how CDI works in a more "real world" way than the spec and describes the specific parts in Weld as well.

Weld also contains a great tool to learn CDI or check what is happening in your CDI deployment: Weld Probe.
Probe gives a graphical UI to monitor your bean graph and all the internal CDI configuration in your deployment

Weld is used in the following application servers:

* Oracle Glassfish
* JBoss Wildfly
* Oracle Weblogic
* JBoss EAP
* IBM WebSphere liberty profile (from 8.5.6)

To learn more on Weld see <<weld_specific>> or visit JBoss Weld website (http://weld.cdi-spec.org).


[[intro_owb]]
=== Apache OpenWebBeans

OpenWebBeans got its name from early CDI project name.
The implementation from the Apache foundation is of course under Apache License.
It's a fast and very modular implementation.
The implementation is organized around a core engine and a series of plugin for integration with various Java EE specification.

Apache OpenWebBeans is used in the following server:

* Apache TomEE
* IBM WebSphere Liberty profile (until 8.5.6)

To learn more on OpenWebBeans see <<owb_specific>> or visit Apache OpenWebBeans web page (http://openwebbeans.apache.org/).

[[intro_candi]]
=== Caucho CanDI

CanDI is a CDI 1.0 implementation at the heart of Caucho Resin 4.x.
It is used to configure the server and provide all the integration layer between all the server technology.
Unfortunately CanDI is not available as standalone solution.

[[resources]]

== The CDI website and other resources for learning CDI
////
Create an appendix titled "Resources" and move all the resource information (and maybe the CDI website information) into that appendix. --MM
////

////
TODO: write part on CDI website
////

[[cdi_alternatives]]
== Alternatives to CDI

CDI is not the first or only solution to add dependency injection to your project.
Other frameworks provide similar features with different flavors.

In this section, we give a short introduction to the three major alternatives to CDI.
As with CDI, they all implement the JSR 330 (AtInject) specification.

////
Add more information on what you mean when you say that these are alternatives to CDI. Are these things that your readers might consider using instead of CDI? Or in addition to CDI? --MM
////

If you need more information on any of these alternatives, refer to the specific websites and documentation.

[[spring]]
=== Spring Framework

Spring is the open source framework that made the concept of dependency injection popular more than 10 years ago.
The project is led by Pivotal under Apache License.
Spring is probably the most popular dependency injection framework for Java.

The IoC approach in Spring is very close to CDI one.
The major difference being that CDI support only strong typed injection where Spring also support injection based on Id (string).

You'll find more information on Spring on the project website: http://spring.io


[[guice]]
=== Google Guice

Google launched Guice a few years after Spring.
The project is also published under Apache License.

Guice has a strong typed approach for IoC like CDI does, but provides more programmatic solution for configuration and injection.

It was also a good solution for adding IoC to Android platform, but today it is surpassed by Dagger.

You'll find more information on Guice on the project website: https://github.com/google/guice/wiki/Motivation


[[dagger]]
=== Google Dagger

Introduced in 2012 by Square, Dagger is one of the youngest in the Java IoC open source frameworks family.
It is also developed under the Apache License.
Dagger was thought for Android platform, and is the lightest solution out there to do IoC.

The framework generates static code at compilation time by processing the annotations.
The counter part of this lightness is less dynamic aspect than other framework at runtime.

Dagger 2 is now led by Google.

You'll find more information on Dagger on the project website: http://google.github.io/dagger/

== Summary
////
Rewrite this summary in the form of a bulleted list, where each bullet takes the form "Statement of fact. Relevance of that fact." I sent you some examples many months ago; I've re-sent them. We can discuss this in more detail when we meet. --MM
////

In this chapter we met CDI.
We saw the main CDI concepts like dependency injection or context management and discovered how its programming model can help you focusing on the business code in your development.

We also how being a JSR specification made CDI specific and present the two implementation for it.

Finally we listed the alternatives solution to CDI and show how they differs from it.

In the next chapter we'll show a CDI code example from scratch and help you getting ready to work with the book examples.