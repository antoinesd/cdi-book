[[chap02-getting-started]]
== Getting started

Starting to work on a new framework is like travel into a foreign country.
It's exciting but can be a bit confusing.
Discovering everything by yourself can be time consuming, and you could miss something important.

This chapter will be your guide to prepare your travel in CDI land.
See it like getting a tourist guide, plane ticket and packing the right stuff to visit this new framework.

To give you an overview of what awaits you in this new land, we'll start with a concrete CDI example.  

Concretely, in this chapter, we'll cover these points:

* Exploration of a complete CDI example from scratch 
* Introduction of the tools used in this book 
* installation of the environment required to run examples of the book
* how CDI is supported in the major IDE
* others resources to help you learn CDI

[[example]]
=== Example, from scratch to full CDI

The best way to understand some of the problems solved by CDI is by taking an example.
Suppose we're planning to develop a micro-blogging platform.
Users can sign up to the platform an
A user can submit a new post and all her followers will receive a notification in the browser and see this new content.
Each user can see her own post and the post of users she's following.
This set of posts is called user's timeline.

We could build a simple schema of such an application like this:

.basic micro-blogging example
[plantuml, generated_chap01-1, svg]
----
@startuml



PostService ..> UserRepository : Uses
PostService ..> PostRepository : Uses
PostService .> NotificationService : Uses
NotificationService <|-- WebSocketNotificationService
UserRepository <|-- JpaUserRepository
PostRepository <|-- JpaPostRepository



class PostService{
    +List<Post> getTimeLine(User)
    +postMessage(User, Post)
}

interface NotificationService{
    notifyUsers(List<User>, Post)
}

class WebSocketNotificationService{
    +notifyUsers(List<User>, Post)
    -RemoteEndPoint getEndPoint()
}

interface UserRepository{
    List<User> findFollowers(User)
}

interface PostRepository{
    Post savePost(User, Post)
    List<Post> getAllPostFromUser(User)
}

class JpaUserRepository{
    +List<User> findFollowers(User)
    -EntityManager getEntityManager()
}

class JpaPostRepository{
    +Post savePost(User, Post)
    +List<Post> getAllPostFromUser(User)
    -EntityManager getEntityManager()
}

@enduml
----

The `PostService` class is the main service entry point.
For this class we can get the timeline and submit a new post for a given user.

It uses two repositories to interact with users (`UserRepository`) and posts (`PostRepository`).
Each of these repositories have one implementation based on a RDBMS and accessed through JPA engine.
Having this interface/implementation approach allow us to easily change the way data is stored in the future, by providing a new implementation, for a NoSQL database for instance.
It is also a good practice regarding application testing, allowing us to provide mocks the repositories if we want to test `PostService` without testing JPA engine.

`PostService` also uses the `NotificationService` interface to be able to send notification to users when someone submit a new post.

Let's focus on PostService and see how it would be designed without CDI and then what CDI could simplify and solve in this design.


==== Without CDI

Without an integration framework like CDI, we'll have to instantiate the classes ourselves by sing the `new` keyword.

Regarding `PostService`, we need to provide the class a way to initialize its 3 services.
The most obvious solution to do so is to add a constructor taking the 3 types i parameter to perform this initialization.

The result would be:

[[postservice_without_cdi]]
.`PostService` without CDI
[source]
----
include::{sourcedir}/chap02/nocdi/PostService.java[tags=snippets]
----
<1> As we have to write to RDBMS, we need to handle transaction lifecycle
<2> we need a constructor to initialize the required services with different implementations
<3> If we want to notify other services, we'll have to add these to the class and the calls here

Using the class above will bring the following issues:

===== Instantiation

To have our `PostService` object we'll need a place in the code were we instantiate it.
This place will have to instantiate other services as well to pass them to `PostService` constructor.

.`PostService` instantiation
[source]
----
PostService ps = new PostService(new WebSocketNotificationService(),
    new JpaPostRepository(), new JpaUserRepository(),
    getTransactionManager()); //<1>
----
<1> to keep this example simple, we won't detail how `TransactionManager` is retrieved

The main default of this instantiation is probably the fact that implementation detail are now hard coded in our application.
Should we need to switch from JPA to another repository approach, we'd have to change the code.

By the way that's what we would do when testing `PostService` class.

.`PostService` instantiation for test
[source]
----
PostService pst = new PostService(new MockNotificationService(),
    new MockPostRepository(), new MockUserRepository(),
    new MockTransactionManager());
----

Another drawback of this instantiation is that the wiring between `PostService` and its dependent service is defined neither in `PostService` nor in the dependent components but in a third place that could be hard to find when browsing the code.

===== Uniqueness

Business application are designed in layer. Like we did in our small example with a service layer and a repository (storage layer).
For a lot of reason (concurrency issues, memory footprint), we often need that a given component is instantiated once for the whole application.

This approach (called "Singleton Pattern") could be very tricky to implement from scratch.
In our example nothing prevent us to instantiate as many `PostService` as we wish.
A lot of technical code have to be added to our example to enforce this pattern, should we require it as architecture good practices recommend.

===== Technical code inclusion

An other big issue of this raw approach is the mix of technical with business code.
In <<postservice_without_cdi>>, `postMessage` method have to manage database transaction and message submission at the same time.

Mixing business code with technical code (transaction, security or audit management) add a lot of noise and repeated code fragment.

Side effect of this is easy to guess:

* the code is harder to read and maintain
* the true value of code (business treatment) is burried in boilerplate code
* technical code being repeated every is virtually impossible to maintain
* your project technical debt reach to the moon before you realize it


===== Coupling with non or hardly related services

Last issue in <<postservice_without_cdi>>, is probably the notification part in `postMessage` method.
It's not a real issue, but could become one, if notification goes beyond a simple call.

If a new service is added later tot he application and this service needs to do a task when a post is save, you'll have to change the code of `postMessage` to add these call and of course add the corresponding service as a new field in `PostService`.

==== With CDI

Here's the CDI version of `PostService`:

[[postservice_with_cdi]]
.`PostService` with CDI
[source]
----
include::{sourcedir}/chap02/cdi/PostService.java[tags=snippets]
----
<1> Solves uniqueness by giving the bean a scope
<2> Solves instantiation and dependency to implementation
<3> Solves coupling to non related service with events
<4> Solves technical code inclusion

Let's check how CDI solve issue or limitations in <<postservice_without_cdi>>.

===== Instantiation

With CDI we don't have to instantiate the service object and other dependent services.
The CDI container does this job for us by:

* registering a _bean_ for each service class found
* providing us a _bean instance_ each time the application needs one
* managing injection of a bean instance at each _injection point_ (place having the `@Inject` annotation).

When registering a bean, the container computes and associates its set of types, including its interfaces and even `Object` type.

For instance the set of types content for the bean defined by `JpaPostRepository` class is:

* `JpaPostRepository`
* `PostRepository`
* `Object`

That means that an instance of this bean is potentially (with conditions will detail later) a candidate for any injection point on this types.

Thus we can avoid mentioning implementations wiring in our application.
It's done naturally by the CDI container.

You might wonder what will be the entry point to this bean world (i.e. how to get the bean instance for PostService)?
We can get this instance in many ways. the most obvious being:

* If we add `@Named` annotation on the class it will be accessible from user interface by Expression Language `#{postService.getTimeline(user)}`
* We can add an _observer_ for the beginning of the _Application Context_. It'll be triggered automatically by the container when its boot phase is over.
* Eventually, we can access the container form outside CDI, thanks to the `CDI` class and its `getCurrent()` static method:

.request an instance of `PostService` from outside CDI
[source]
PostService ps = CDI.getCurrent().select(PostService.class).get();

===== Uniqueness

The CDI container handle singleton pattern thanks to scopes and context management.
When a bean has a normal scope (most scopes except `@Dependent`), the container guarantee that there will be only instance of this bean in the matching context.
In <<postservice_with_cdi>> example, the `PostService` class has the `@ApplicationScoped` annotation.
It makes the container to register the bean from that class with application scope.
So the container will ensure that the Application Context will hold maximum one instance of this bean, making it a singleton for the application.

===== Technical code externalisation

CDI provides two main solutions to externalise technical code.
It can be done with:

* _portable extensions_ that will deal with the technical part at boot time
* _interceptors_ that will enrich the business code with transverse technical behaviour

In <<postservice_with_cdi>> example we chose the second approach, by using an interceptor provided by the Java Transactional API (JTA) specification.
The `@Transactional` annotation is bound to an interceptor which takes care of transaction for us.
When a method is intercepted, the code of the interceptor is called instead of the method.
The interceptor receives all needed information on the intercepted method to be able to call it if its behaviour requires it.

As the interceptor code is provided by our JTA implementation, we have nothing else to do to use this feature.

This interceptor start a transaction, then call the original method and eventually commit the transaction with all the required error management around this expected workflow.

===== Decoupling with non or hardly related service

With dependency injection, CDI provides a great way to loose the coupling (inter dependency) between all application beans.
But it can do even more by allowing a given bean to communicate with another bean without any dependencies between them.
This feature is done thanks CDI eventing system.

In <<postservice_with_cdi>> we injected the CDI `Event<T>` type with `NewPost` class as Event parameter type.

It allows us to trigger events of type `NewPost` which a simple class containing a `Post` and list of users linked to this `Post`.

.The `NewPost` class
[source]
----
include::{sourcedir}/chap02/cdi/NewPost.java[tags=snippets]
----

To observe this event an other bean need to define an observer method.
It's as simple as shown below 

.The `WebSocketNotifService` class
[source]
----
include::{sourcedir}/chap02/cdi/WebSocketNotifService.java[tags=snippets]
----

With this feature, a bean can send a notification to unknown bean at development time adding more decoupling and modularity to the application.



[[tools]]
=== Tools used in this book

As the world of Java IDE is moving rather fast (roughly a new major version each year), we decided to focus the example on the book on command line tools.

In addition to JDK 8, these tools are:

* Apache Maven
* Git version control solution
* JBoss Arquillian (used with JUnit)

This choice has many advantages:

* it avoids us to provide you with outdated screen capture of available IDE at book writing time
* our code and examples will be working in all IDE, since all of them integrate the tools above
* this tools are commons to most professional development environment, so our example are also ready to be added to your continuous integration solution

This said, we recommend that you use an IDE to work on our example, but you are free to choose the IDE that suits your need.
In <<ide_support>> you'll get all the information to choose the best IDE for you.

Now let's discover the tools used all along  this book. 

[[maven]]
==== Apache Maven

Maven is probably the most popular build tool in the Java ecosystem.

Its 2 main features are:

* Java dependency management
* Java project build

[[dependency_management]]
===== Dependency management

Most Java project needs with third party libraries (jar files) to be compiled or executed.
It is said that these libraries are dependencies for the given project.

Without an engine to manage these dependencies, project manager would have to add these libraries in their correct version to the project.
That brings multiple problems.
The most obvious being:

* Transitive dependencies: when adding a third party library, project manager might also need to add dependencies for this library.
 So the project dependencies might lead to a lot of jar to your project
* Size of the project: adding these extra jar will make the project much bigger than its code source
* Binary in source project is a bad practice and should be avoided
* Management of the libraries: when you decide to change version of library you have to remove the previous jar and a new one
* Conflict management: when adding dependencies' dependencies, project may fall in dependency hell by having the same jar in multiple version in the project.
 
Maven solves (or ease) all of these problems by providing a powerful solution to manage dependency in a Java project.
This solution relies on online dedicated repositories for all java libraries and coordinate mechanism to design a specific library in a given version.

[[maven_build]]
===== Maven build

Beyond dependency management, Maven provides a standard way for building and testing code in a Java project.

It was one of the first building tools to adopt a "convention other configuration" approach.
Thus, Maven suppose that there's a standard (conventional) way to build a java application (jar, war or ear) and provides all the steps to perform this build by default.
This collection of steps (also called phases) are the Maven "standard lifecycle", i.e. the set of operation to perform a standard build.

Of course standard build is not always the one needed by user so it can be modified by adding configuration and plugins to the Maven configuration file (`pom.xml` file).
That's why maven file, is more a configuration file than an instruction file.

For instance, the Maven convention suppose that the source code is placed in `src/main/java` folder of the project.
So by default Maven will look for class to compile in this folder.
If you want to have your source code in another folder, you'll have to add this information in the Maven configuration file.


.Main phases in Maven default lifecycle
|===
|Phase|Description

|`validate`
|validate the project is correct and all necessary information is available

|`compile`
|compile the source code of the project

|`test`
|test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed

|`package`
|take the compiled code and package it in its distributable format, such as a JAR.

|`integration-test`
|process and deploy the package if necessary into an environment where integration tests can be run

|`verify`
|run any checks to verify the package is valid and meets quality criteria

|`install`
|install the package into the local repository, for use as a dependency in other projects locally

|`deploy`
|done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.
|===

In this book we'll mainly use the `test` and `deploy` phases to hook our own behaviour to Maven build. 

[[pom]]
===== Maven pom file and command

Maven configuration file is by default in xml format and is called `pom.xml`.

Below you'll find a simplified version of our example pom:

.A basic `pom.xml` file
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>
	<groupId>org.cdi2inaction</groupId>
	<artifactId>cdibook-examples</artifactId>
	<version>1.0-SNAPSHOT</version> <!--1-->

	<properties> <!--2-->
		<maven-compiler-plugin.version>3.3</maven-compiler-plugin.version>
		<maven-compiler-plugin.javaversion>1.8</maven-compiler-plugin.javaversion>
	</properties>

	<dependencies> <!--3-->
		<dependency>
			<groupId>javax</groupId>
			<artifactId>javaee-web-api</artifactId>
			<version>7.0</version>
		</dependency>
		
	</dependencies>

	<build> <!--4-->
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>${maven-compiler-plugin.version}</version>
				<configuration>
					<source>${maven-compiler-plugin.javaversion}</source>
					<target>${maven-compiler-plugin.javaversion}</target>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
----
<1> coordinates of the current project (`groupId`, `artifactId` and `version` identify a unique 3rd party lib)
<2> this section allows to define variables that will be used by Maven engine or this project configuration
<3> this section defined all the third party libraries on which this project depends
<4> this section defined how this project should be build.
It is mainly composed of plugins which alters the default Maven build behaviour

With this pom file in the root folder of the project, the build of this project can be triggered by issuing the following command in the terminal:
 
`mvn package'

[[maven_conclusion]]
===== Maven in this book

You don't need to be a Maven expert to read this book and use the example, but it's a good thing to understand what this tool is and how to use it.

In this book we'll use Maven to build, test and automatically deploy or run CDI application from command line.
It will free us from the description of a lot of other tools (like application servers) and help us to be more focused on CDI. 
 
If you want to learn more about maven, you'll find more information on https://maven.apache.org/[Maven website].
You can also read the free books written by Sonatype (the company behind Maven):

* http://books.sonatype.com/mvnex-book/reference/public-book.html[Maven by Example]
* http://books.sonatype.com/mvnref-book/reference/[Maven the complete reference]


[[git]]
==== Git

Modern development cannot be conceived today without source code management (SCM) solution.
A SCM (also called version control system) is a way to keep track of a project history and manage multiple version of the project at the same time.

These tools appeared as proprietary solution in the 70's and were widely adopted during the 90's when popular free solutions like CVS appeared.

Today there two approaches for SCM:

* Centralized one where there is only one repository used by all developers through client/server calls.
Subversion (SVN) is probably the most popular solution build on this paradigm.
* A more recent approach: the Distributed SCM (or DVCS) where all developers have their own repository and push the work they want to share in a central repository.
Git is in this family with other solution like Mercurial or Bazaar.

Git success brought new online platform to share code for open source project.
The most popular platform today is probably http://github.com[Github].
That's why you'll find the book code on Github and that git is required to get this code.
// TODO: Add link to book repo

Git is a very powerful and potentially complex tool, so starting describing how it works is well beyond this book.
We'll only give you the required command to get the code repository from Github and how to switch from different branches to get the example amtching to the current chapter when needed.
 
If you want to learn more about git, we suggest following resources:
 
* Documentation on official https://git-scm.com/[Git Website]
* Atlassian free https://www.atlassian.com/git/[Git tutorial]

[[arquillian]]
==== JBoss Arquillian

Code testing is today a good practice widely adopted in serious project.
It's an easy way to define how the code should behave by creating a kind of "active" specification for the project.

At software level, it is common to distinguish unit tests and integration tests.

While unit tests are useful to test business logic in our code, integration tests is useful to check that different component of the application work well together.
When dealing with a technology like CDI where the componentization could also be part of business logic (CDI extension or interceptor could be part of it for instance), basic unit test could be not enough to effectively test the code.
And yet, we do not wish to perform these tests as integration tests since their failure should stop the build in the same way than an unit test does. 

JBoss Arquillian brings a solution to this need.

Arquillian is a testing solution that can be plugged on standard unit test framework like Junit or TestNG to allow testing in a container.

In an Arquillian test, the developer defined what is deployed (class, packages, third party libraries) and can launch tests against this deployment in a chosen container.

Arquillian container adapter may be choose among a huge collection and should be defined in the Maven configuration file.

In this book examples we'll mainly use basic Weld and OWB embedded container adapter to test our code but keep in mind that Arquillian provide a wide range of container adapter for most Application server available.

===== Arquillian example

If we go back to our example in <<example>> we could want to test if the event of type `NewPost` fired in `PostService.postMessage()` is effectively triggered once.

As we don't have a lot of business code here, this test is more a "let's test CDI" which is rather useless, but the goal here is to show you how Arquillian can be used to perform such a test.

First, let's start by how we added Arquillian engine in the project `pom.xml:`

.Micro blogging `pom.xml` file with Arquillian dependencies
[source, xml]
----
include::{codedir}/pom.xml[]
----
<1> To support unit testing we have to add `Junit` framework as a dependency
<2> The Arquillian Junit container allow Arquillian to be used in Junit tests
<3> The Weld embedded container is a light CDI container based on Weld to perform our tests

So we just had to add 3 dependencies to be able to test our CDI code with Arquillian.
Note that here we are using Junit but TestNG framework is also supported by Arquillian

Next step, we need to add a bean in our test code to catch the number of event triggering.
The `NewEventObserverBean` contains one listener that will increment an int each time it is called.

.The `NewEventObserverBean` class
[source]
----
include::{testdir}/chap02/cdi/NewEventObserverBean.java[tags=snippets]
----
<1> the bean is declared in ApplicationScope to keep track of the counter during all the life of the container
<2> when this observer is triggered the counter is incremented

To finish, we have to create our test class based on Junit and Arquillian. 

.The `PostServiceTest` class
[source]
----
include::{testdir}/chap02/cdi/PostServiceTest.java[tags=snippets]
----
<1> this annotation indicates that this Junit test should be launched with Arquillian Junit adapter
<2> a Junit test class should always contain a static method annotated with `@Deployment` and returning an archive build with shrinkwrap framework included in Arquillian
<3> here we build the archive by adding all the class in the `chap02` package
<4> and a `beans.xml` to be sure that CDI will be activated in this archive
<5> the arquillian nature of the test allows us to inject CDI beans in test class
<6> eventually we can use the injected beans to initiate code and test the ouctome.

===== To learn more on Arquillian

Most of the Arquillian test you'll see in this book will follow the same schema.
So you don't have to learn a lot more to understand test code in our sample.

Yet Arquillian is a very interesting topic, if you want to learn more about it check:

* the http://arquillian.org[Arquillian website]
* the excellent "Arquillian in action" book.


[[installation]]
=== Installing your environment

[[ide_support]]
=== CDI Support in major IDE 


